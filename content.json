{"meta":{"title":"韩元桢博客","subtitle":"程序猿，创客，水瓶座","description":"韩元桢博客 技术博客 学习总结 思考感悟 知识管理","author":"HanYuanZhen","url":"http://hanyuanzhen.com"},"pages":[{"title":"","date":"2017-03-27T06:47:36.043Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"404.html","permalink":"http://hanyuanzhen.com/404.html","excerpt":"","text":"404"},{"title":"about","date":"2015-10-19T10:17:14.000Z","updated":"2017-03-27T06:19:43.220Z","comments":true,"path":"about/index.html","permalink":"http://hanyuanzhen.com/about/index.html","excerpt":"","text":"关于我 我是一枚90后程序员，技术写作和摄影爱好者，也是一名马拉松跑者，13年大学毕业后我开启程序猿之路。加入蓝港互动，让我独立实现了很多想法，做出了截止目前对我最重要的一个产品「火爆游戏」，这款产品目前服务于各H5游戏的推广，后转型到H5游戏的研发，让自己在技术和互联网产品理念都有质的提升。 做为一个文艺中年，我热爱编程，也喜欢写作，小时候的理想是成为一个作家，后来落入凡尘，靠编码为生。等到基本解决了生活问题，又重新回到了写作这个领域，二者得兼，也算轮回。 微信时代之前，我的文章都放在个人博客上。2015年末，我开始在微信平台「igreeker」上写东西，由于文字有一点质量和趣味，为「igreeker」赢得了一些fans。 我的技术背景：编程语言：Java、Python、Android相关技术：Web Architecture、User Experience、Linux/Unix、Application Platform另外，我在带团队和产品管理方面也有一点心得，我也喜欢产品设计工作。 社区信息：豆瓣：http://www.douban.com/people/w2cboy/微博: http://weibo.com/xuanfengwu微信平台：igreeker"},{"title":"分类","date":"2015-10-19T10:14:49.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"categories/index.html","permalink":"http://hanyuanzhen.com/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2015-10-21T13:13:09.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"guestbook/index.html","permalink":"http://hanyuanzhen.com/guestbook/index.html","excerpt":"","text":""},{"title":"tagcloud","date":"2015-10-19T10:11:36.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"tags/index.html","permalink":"http://hanyuanzhen.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2015-10-19T10:14:49.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"tools/index.html","permalink":"http://hanyuanzhen.com/tools/index.html","excerpt":"","text":""}],"posts":[{"title":"jdk源码阅读——ArrayList","slug":"jdk源码阅读——ArrayList","date":"2016-11-09T15:49:00.000Z","updated":"2017-03-27T06:45:25.343Z","comments":true,"path":"2016/11/09/jdk源码阅读——ArrayList/","link":"","permalink":"http://hanyuanzhen.com/2016/11/09/jdk源码阅读——ArrayList/","excerpt":"个人观点：集合类和concurrent下的类是java里特别精髓的东西。","text":"个人观点：集合类和concurrent下的类是java里特别精髓的东西。 概要 类的定义 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 类的继承关系 1234java.lang.Object java.util.AbstractCollection&lt;E&gt; java.util.AbstractList&lt;E&gt; java.util.ArrayList&lt;E&gt; 类的特点 http://blog.csdn.net/u014394255/article/details/53449122 属性1private static final int DEFAULT_CAPACITY = 10; 此属性定义list的默认空间大小 1transient Object[] elementData; 此属性有序缓存数组元素，每增加一个元素，则，用transient修饰，表示不会序列化 方法 初始化 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; 用指定的初始化容量初始化一个空的list toArray 123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; indexOf 123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 检查list中元素是否为null,或在list中的index elementData 1234@SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; 返回访问操作元素位置对应的value add 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 添加参数到list中，rangeCheckForAdd方法会index的上下界进行检查 remove 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 移除list指定位置的值，并释放gc 线程安全 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; 容量扩充 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 设置最小的容量，来扩充list的大小；可以看出，oldCapacity 新增的容量是它的一半。另外，还有一个 hugeCapacity，如果需要扩充的容量比 MAX_ARRAY_SIZE 还大，会调用这个函数，重新调整大小。但再大也大不过 Integer.MAX_VALUE。","categories":[{"name":"jdk源码阅读","slug":"jdk源码阅读","permalink":"http://hanyuanzhen.com/categories/jdk源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://hanyuanzhen.com/tags/源码阅读/"},{"name":"jdk","slug":"jdk","permalink":"http://hanyuanzhen.com/tags/jdk/"}]},{"title":"git教程详解（一）","slug":"git教程详解（一）","date":"2015-11-27T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/27/git教程详解（一）/","link":"","permalink":"http://hanyuanzhen.com/2015/11/27/git教程详解（一）/","excerpt":"git是一个很好的分布式版本管理工具，在git中，版本库又叫仓库，英文名为repository，可以简单的理解为本地的一个目录，用git进行管理，目录内的文件git进行删除，修改等操作时，git都可以跟踪，从而记录仓库的操作历史。","text":"git是一个很好的分布式版本管理工具，在git中，版本库又叫仓库，英文名为repository，可以简单的理解为本地的一个目录，用git进行管理，目录内的文件git进行删除，修改等操作时，git都可以跟踪，从而记录仓库的操作历史。 一、git简介git中，版本库又叫仓库，英文名为repository，可以简单的理解为本地的一个目录，用git进行管理，目录内的文件git进行删除，修改等操作时，git都可以跟踪，从而记录仓库的操作历史。 二、创建仓库在本地创建一个目录，如/user/temp/test/，然后在此目录下执行git init，就可将目录变成git管理的仓库。执行完后，是一个空仓库，包含一个隐藏的.git目录，若没看到该目录，linux上可以用 ls -ah 查看.(1).将文件添加到版本库所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道 。1.现在在test目录或其子目录下添加一个readme.txt ,将该文件放到git仓库方式如下:12git add readme.textgit commit -m \"add new file\" 上述命令中 -m 为本次提交的注释，是为了方便他人查看，所以需要加上。2.若git想批量添加文件，可以将多个文件用逗号分隔，然后commit。12git add test1.txt test2.txtgit commit -m \"add new file\" (2).查看仓库的状态git status命令可以让我们时刻掌握仓库当前的状态。如图: 上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。git diff可以告诉我们修改了什么内容。1git diff readme.txt (3).版本回退git会将修改的文件保存一个快照，一旦你把文件修改乱了或误删除文件，可以从最近的快照恢复，而不影响工作。 git log 查看版本控制系统的修改记录 git log命令显示从最近到最远的提交日志，上述操作我们可以看到有2次提交，每次提交后，都会有一个commit Id(版本号). git reset 回退版本 Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。git reset – hard HEAD^ 比如要将当前版本回退到上一个版本 ,HEAD^也可换成版本号. git reflog 恢复版本 当你用 $ git reset –hard HEAD^ 回退到上一个版本时，再想恢复回来，就必须找到恢复版本的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：git reflog (4)删除文件1.一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 $ rm test.txt2.git rm file 从版本库删除该文件，并且git commit3.git checkout – test.txt 用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 三、远程仓库远程仓库可以是在一台运行git的服务器上创建一个的仓库。类似网站如gitcafe ,github等都可进行仓库的托管。只要注册一个账号，可以获得免费的远程仓库。由于在github上，你本地仓库和远程仓库的传输是通过ssh加密的。所以需要进行如下设置:1.创建SSH key1ssh-keygen -t rsa -C \"***********@163.com\" 创建成功后，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。2.登录github，配置ssh key ，如图所示: 图中的Title任意填上，在Key文本框里粘贴id_rsa.pub文件的内容。github 支持添加多个不同的key,假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了.(1)、添加仓库在上面操作配置好ssh key 后，就可以创建远程git仓库了，在github上，在右上角找到“Create a new repo”按钮，创建一个新的仓库。如图所示 创建好仓库后，需要和你本地的仓库进行关联，然后把本地的内容push到远程仓库中，则你需要在的本地库目录下，执行如下操作:1git remote add origin git@github.com:igreek/Timber.git 执行后，你的远程库为origin。但此时还是没有内容，若把关联的本地库的内容push到origin上，则需要执行如下操作: 1git push -u origin master 参数-u:第一次push时需要，以后可以省略。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 (2)、从远程库克隆假如没有在本地创建仓库，在远程创建了一个仓库，想把远程仓库的内容克隆到本地的一个目录下。可以执行如下操作:1git clone origin git@github.com:igreek/Timber.git 从上面的操作都是使用ssh协议，其实也可以其他的https协议，但它速度有些慢，端口有限制。 总结:本篇主要介绍了git的作用，git 与其他版本工具的一些差异，git的创建仓库以及如何管理仓库等功能，涉及到一些git命令需要熟悉，git也是一个很实用的分布式系统，下篇将介绍git的分支管理。","categories":[{"name":"git教程","slug":"git教程","permalink":"http://hanyuanzhen.com/categories/git教程/"}],"tags":[{"name":"git","slug":"git","permalink":"http://hanyuanzhen.com/tags/git/"},{"name":"版本管理","slug":"版本管理","permalink":"http://hanyuanzhen.com/tags/版本管理/"}]},{"title":"核心java系列——I/O流详解（一）","slug":"核心java系列——I-O流详解(一)","date":"2015-11-24T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/24/核心java系列——I-O流详解(一)/","link":"","permalink":"http://hanyuanzhen.com/2015/11/24/核心java系列——I-O流详解(一)/","excerpt":"流的概念流是一系列有顺序的字节的集合，是网络传输的载体，流可以包装成基本数据类型或对象，流有输入和输出，输入时是从流从数据源流向程序输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。","text":"流的概念流是一系列有顺序的字节的集合，是网络传输的载体，流可以包装成基本数据类型或对象，流有输入和输出，输入时是从流从数据源流向程序输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。 一、流的概念流是一系列有顺序的字节的集合，是网络传输的载体，流可以包装成基本数据类型或对象，流有输入和输出，输入时是从流从数据源流向程序输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等，下面是流的输入和输出的图形化： 二、流的分类(1)、流有字节流，字符流，输入流和输出流等。 根据处理方向不同可分为：输入流和输出流。 根据处理数据类型不同可分为：字节流和字符流。字节流和字符流的处理原理是相同的，只是处理的数据类型不同。字节流是以字节为单位来传输，一个字节是8bit;字符流是以字符为单位来传输，一个字符是16bit。 根据分工的不同可分为：节点流和处理流 (2)、java I/O流基本类有字节流的抽象基类：InputStream(字节输入流),OutputStream(字节输出流)字符流的抽象基类:Reader(字符输入流)，writer(字符输出流)其他类都由这4个抽象基本派生出来，详细的流的类图结构如下: 三、输入和输出流(1)、输入可使用：1.InputStream – 一个字节一个字节(byte)地从数据源读取。读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。int read() ； 读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。int read(byte[] buffer) ；读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。int read(byte[] buffer, int off, int len) ； 关闭流释放内存资源。void close() ;2.Reader – 一个字符一个字符(char)地从数据源读取。读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。int read() ； 读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。int read(char[] cbuf) ；读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。int read(char[] cbuf, int off, int len) 关闭流释放内存资源。void close()(2)、输入流可使用1.OutputStream:向输出流中写入一个字节数据,该字节数据为参数b的低8位。void write(int b) ; 将一个字节类型的数组中的数据写入输出流。void write(byte[] b);将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。void write(byte[] b, int off, int len); 关闭流释放内存资源。void close();*将输出流中缓冲的数据全部写出到目的地。void flush(); 2.Writer:向输出流中写入一个字符数据,该字节数据为参数b的低16位。void write(int c); 将一个字符类型的数组中的数据写入输出流，void write(char[] cbuf) throws IOException将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。void write(char[] cbuf, int offset, int length); 将一个字符串中的字符写入到输出流。void write(String string);将一个字符串从offset开始的length个字符写入到输出流。void write(String string, int offset, int length); 关闭流释放内存资源。void close() throws IOException*将输出流中缓冲的数据全部写出到目的地。void flush() throws IOException 四、读写文本文件(1).写文本文件1.FileWriter是继承writer类，可调用write()方法往文本中写入内容。下面程序为调用FileWriter类的write(type c)方法的实现: 123456String fileName=\"d:\\\\demo1.txt\";FileWriter write=new FileWriter(fileName);write.write(\"hell,io\\n\");write.write(\"welcome to study\\n\");write.write(\"加油，谢谢！\");write.close(); 2.BufferedWriter类是带缓冲区的，比FileWriter要高效些，若写入的内容多优先使用此类，此类有一个newLine()方法，可换行。下面程序为BufferedWriter类write(type c)方法的实现: 12345678//处理内容较多的数据是，用BufferedWriter更高效BufferedWriter bWrite=new BufferedWriter(new FileWriter(fileName));bWrite.write(\"hell,io\");bWrite.newLine();bWrite.write(\"welcome to study\");bWrite.newLine();bWrite.write(\"加油，谢谢！\");bWrite.close(); 不论使用哪种方式，结束时都需要close()关闭流，否则会导致资源耗尽问题。(2).读文本文件1.FileReader类是从文本文件读取字符，下面代码为FileReader类读取文本文件的实现，返回的是一个int类型数。若读取到末尾，则返回-1，下面为具体的实现: 12345FileReader read=new FileReader(fileName);int len=read.read();while(len!=-1)&#123; System.out.println(\"len:\"+len); &#125; 2.BufferedReader类是文本文件读取的缓存器类，调用readLine()方法，可一行一行的读取出整行字符，若读取到末尾返回null,下面为具体的实现: 1234567BufferedReader read=new BufferedReader(new FileReader(fileName));String line=read.readLine();while(line!=null)&#123; System.out.println(\"line:\"+line); line=read.readLine();&#125;read.close(); 同时不论使用哪种方式，结束时都需要调用close()关闭流，否则会导致资源耗尽问题. 五、读写二进制数据对于纯文本文件里的内容都可解释为字符，可以用Reader和writer进行读写，但对于那些图片，声音的不是纯文本的内容，则需要利用二进制的字节方式进行读写，利用二进制字节读取数据要比字符快，且编码问题小。(1).写二进制字节数据FileOutputStream类:用于字节的输出；DataOutputStream类:用于将数据写到另一个输出流。下面为具体的实现: 12345DataOutputStream out =new DataOutputStream(new FileOutputStream(fileName));out.writeInt(1);out.writeDouble(11.20);out.writeUTF(\"test\");out.close(); (2).读二进制文件 通过另外一个流来构造一个过滤流，常用的子类有DataInputStream 和 BufferedInputStream。后者是将字节数据读取到缓冲区.相对要高效些。下面为具体的实现: 1234String fileName=\"d:\\\\demo.dat\";DataInputStream in=new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)));System.out.println(in.readInt()+\"-\"+in.readDouble()+\"-\"+in.readUTF());in.close(); 还有几个特殊的类,如:LineNumberInputStream:构造一个读取指定的输入流的输入​​的新行号输入流。PushbackInputStream:构建一个可预览一个字节或具有指定尺寸的缓冲区的流。总结：本文主要分析了流的作用，流的分类，流的类图结构以及流的一些操作，比较基础，下篇将介绍流的文件管理，文档的压缩和对象序列化等操作。","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"}]},{"title":"核心java系列——异常处理机制","slug":"核心java系列——异常处理机制","date":"2015-11-24T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/24/核心java系列——异常处理机制/","link":"","permalink":"http://hanyuanzhen.com/2015/11/24/核心java系列——异常处理机制/","excerpt":"异常是程序中一种错误，可能是读取文件错误，网络连接错误，也可能是数组越界错误，或试图使用一个没有被赋值的对象而引起的错误。如果由于异常或错误使程序操作没有操作完成，则程序返回一个安全状态或捕获异常的处理结果，保证程序的健壮性。","text":"异常是程序中一种错误，可能是读取文件错误，网络连接错误，也可能是数组越界错误，或试图使用一个没有被赋值的对象而引起的错误。如果由于异常或错误使程序操作没有操作完成，则程序返回一个安全状态或捕获异常的处理结果，保证程序的健壮性。 一、什么是异常 异常是程序中一种错误，可能是读取文件错误，网络连接错误，也可能是数组越界错误，或试图使用一个没有被赋值的对象而引起的错误。如果由于异常或错误使程序操作没有操作完成，则程序返回一个安全状态或捕获异常的处理结果，保证程序的健壮性。 ####（1）.异常分类java语言中，定义了许多的异常类，所有异常类都派生Throwable类，而Throwable类又有两个子类Error和Exception，分别表示错误和异常，其中Exception又分为运行时异常和非运行时异常。下面为异常的体系结构图： ####（2）.下面将详细说明图中相关异常的区别和联系1.Error和Exception Error是程序无法处理的错误，通常有内存溢出异常(outofMemoryError)，线程终止等，出现这类异常java虚拟机会选择终止程序。 Exception是程序可处理的异常，它又有两个分支运行时异常和非运行时异常，出现这类异常是程序需要处理。2.运行时异常和非运行时异常 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、 IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引 起的，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常。 (3).什么时候抛出异常如果遇到无法处理的问题时，该方法可以选择抛出异常，至于何时需要在方法中用throws声明异常，若该方法需要抛出多个异常，则每个异常间用逗号分隔，通常有以下情况需要抛出异常：1.调用一个已抛出异常的方法，如FileInputStream构造器。2.程序运行过程错误，并用throw抛出一个检查出的异常。3.程序出现错误。4.java虚拟机和运行时库出现的内部异常。总之一个方法必须声明所有可能抛出的异常已检查异常，所有未检查出的异常要么不可控制，要么就应该避免发生。 (4).创建异常创建异常通常只需要定义派生于Exception类或派生于Exception子类的类。例如定义一个派生于IOException的类，通常定义两个构造器，一个是默认构造器，一个是带有详细描述信息的构造器。如: 123456789101112131415161718public class MyExcetion extends IOException &#123; private static final long serialVersionUID = 1L; public MyExcetion() &#123; &#125; public MyExcetion(String message) &#123; super(message); &#125; public MyExcetion(Throwable cause) &#123; super(cause); &#125; public MyExcetion(String message, Throwable cause) &#123; super(message, cause); &#125;&#125; 二、异常处理程序运行过程中，若出现异常没有及时处理，则会终止程序的执行。可以用捕获异常或抛出异常来处理。若try语句代码块出现异常，程序会在catch中寻找匹配的异常，然后调用匹配的异常处理器进行处理。运行过程中程序未找到匹配的异常处理器，程序就会终止。(1).try…catch模式该模式的定义形式如下try{ 代码块； }catch(Exception e){ } Catch(Exception e2){ } 匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹。(2).try…catch…finally模式该模包含finally,无论程序有无异常发生，且不管try –catch间是否顺利执行，都会执行finally语句。(3).实例说明：1.各模块的作用try块:用于捕获异常，后面可以跟一个或多个catch，finally可有可无，但必须有一个catch块。catch块:用于处理异常。finally块是程序是否有无异常，都需要执行的部分。但在以下3中特殊情况下不会执行：A．在finally 语句中发生异常。B．程序所在线程死亡。C．在前面的代码中出现了system.exit()退出程序。2.当捕获到一个异常对象之后，你可以调用其getMessage()方法来获取异常消息，或者调用printStackTrace()方法来打印执行栈的内容关于getMessage()方法当你通过new Exception(“message”)或new RuntimeException(“message”)来创建一个异常对象的时候，传给构造方法的这个参数就是消息，所以，当你捕获到异常对象之后，可以通过getMessage()方法把消息拿出来！关于printStackTrace()方法它能把执行栈的内容打印出来 三、异常的转换所谓异常转换，即截获一个异常（往往是checked exception）之后，将其转换为另外一个异常（往往是unchecked exception）抛出。比如很多情况下，当我们操作数据库的时候或操作文件的时候，JDK类库中的相关操作方法会给我们抛出SQLException或IOException，这些都是checked exception，这些异常一般情况下我们是无法进行处理的，所以，我们需要继续向上抛出异常，假如我们继续抛出SQLException或IOException的话，会导致更上层的程序处理起来非常困难（而且也需要在方法中进行声明）。因此，大多数情况下，我们在截获到SQLException或IOException之后，会将它转换为一种RuntimeException重新抛出，这是非常常见的异常应用技巧！ 四、异常链所谓异常链，即当我们在截获一个异常，在把它转换为另外一个异常的时候，记得把原来那个异常对象设置到新的异常对象中即可。我们不妨观察Throwable类（所有异常类的基类）的构造方法:public Throwable()public Throwable(String message)public Throwable(String message, Throwable cause)public Throwable(Throwable cause)我们注意到其中的Throwable类型的参数，它就是用来创建异常链的。下面使用一个实例来说明:1.自定义异常类： 12345678910111213141516171819202122public class MyException extends RuntimeException &#123; private static final long serialVersionUID = 1L; private String errorCode; public MyException() &#123; &#125; public MyException(String message,String errorCode) &#123; super(message); this.errorCode=errorCode; &#125; //用于创建异常链 public MyException(String message,String errorCode,Throwable cause) &#123; super(message, cause); this.errorCode=errorCode; &#125; public String getErrorCode() &#123; return errorCode; &#125;&#125; 2.调用该类 123456789101112131415161718public class FileUtils &#123; public static String readFile(String filePath)&#123; StringBuffer sb=new StringBuffer(); try &#123; BufferedReader reader=new BufferedReader(new FileReader(filePath)); String line=null; while((line=reader.readLine())!=null)&#123; sb.append(line); &#125; &#125; catch (FileNotFoundException e) &#123; //将原始对象放到新对象中去 throw new MyException(\"文件没有找到！\", \"1\", e); &#125; catch (IOException e) &#123; throw new MyException(\"文件读取有误！\", \"2\", e); &#125; return sb.toString(); &#125;&#125; 五、注意事项1) 必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。2) 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。3) 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块。4) 可嵌套 try-catch-finally 结构。5) 在 try-catch-finally 结构中，可重新抛出异常。6)多个catch的顺序一定要遵循子类在上父类在下的规则。7)一个方法被重写，被重写的方法必须抛出相同的异常或异常的子类。8)若父类方法抛出多个异常，那子类重写该方法必须抛出哪些异常的一个子集。","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"}]},{"title":"核心java系列-抽象类和接口","slug":"核心java","date":"2015-11-20T11:17:27.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/20/核心java/","link":"","permalink":"http://hanyuanzhen.com/2015/11/20/核心java/","excerpt":"##简介 java中，抽象类和接口是支持抽象概念的两种机制，因为它们的存在，赋予了java强大的面向对象编程能 力。接口抽象类在抽象定义上有很多相似地方，甚至可以相互替换。但它们还是有区别的，下面从接口，抽象类以及两者的区别等方面来分析。","text":"##简介 java中，抽象类和接口是支持抽象概念的两种机制，因为它们的存在，赋予了java强大的面向对象编程能 力。接口抽象类在抽象定义上有很多相似地方，甚至可以相互替换。但它们还是有区别的，下面从接口，抽象类以及两者的区别等方面来分析。 ##一、抽象类在面向对象领域，一切都可以理解为对象，对象可以用类来描述。但不是所有的类都是来描述对象的。这些类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、 设计中得出的抽象概念，是对一些类的本质的抽象。比如在车子的类别中，有自行车，桥车，它们的本质属性都可以归类为车，但这个车不能描述出自行车和桥车的区别，需要通过自行车的定义来具体描述车的性质，所以车可以理解为一个抽象类的概念。(1).在面向对象中，抽象类是不能是实例化的，在抽象类中可以定义一组抽象方法，即没有具体实现的方法，在方法前加上abstract关键字来修饰。这些抽象方法的实现需要具体的派生类去实现。(2)抽象类也可以继承，其目的也是为了体现继承，抽取出类的相同性质，体现OOP原则。所以在使用抽象类时需要注意以下几点: 抽象类不能被实例化，若一个类包含了一个以上的抽象方法，那么这个类也必须定义为抽象类（即必须也用abstract来修饰这个类）。 抽象类的抽象方法必须由其其子类实现。 抽象类中可以保护具体的实现方法，也可以不包含抽象方法 abstract不能与final并列修饰同一个类。 abstract 不能与private、static、final或native并列修饰同一个方法。 下面通过一个实例来说明 1234567891011121314151617181920212223242526272829303132public abstract class Bird &#123; public abstract void fly(); public void eat()&#123; System.out.println(\"鸟会吃虫子...\"); &#125;&#125;public class Eagle extends Bird &#123; @Override public void fly() &#123; &#125; public void crash()&#123; System.out.println(\"Eagle...会抓老鼠\"); &#125;&#125;public class Parrot extends Bird &#123; @Override public void fly() &#123; &#125; public void sign()&#123; System.out.println(\"Parrot \"); &#125;&#125;public class AbtractTest &#123; public static void main(String[] args) &#123; Bird b1=new Parrot(); Bird b2=new Eagle(); b1.fly(); b2.fly(); &#125;&#125; ##二、接口接口不是类，是类的功能的描述，不能实例化一个接口，只能new接口的实现类。它比抽象类更加抽象。接口是类所依赖的一种规范化形式，没有具体的实现方法，若实现该接口类，则必须实现该接口的所有方法，用implements是实现，接口的定义由interface声明。接口是对抽象类的一种可扩展，因为抽象类是不能实现多继承的，但接口可以实现多继承，各被继承的接口由逗号分隔，当然接口和抽象类可以联合使用，如 A extends B implements C,D{};在接口使用中需要注意以下几点：1.接口中的所有方法必须要被实现。2.接口只可以定义不可变的成员变量。如 static final String A_PARAM=””;3.接口不能用new去实例化,但可以声明一个接口变量，该变量必须引用一个实现该接口的类的对象，可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。实例介绍如下: 1234567891011121314151617 #接口 public interface Common &#123; public void run() throws Exception; &#125; #实现类 public class CommonImpl implements Common &#123; @Override public void run() throws Exception &#123; &#125; &#125; public class InterfaceTest &#123; public static void main(String[] args) throws Exception &#123; CommonImpl cl=new CommonImpl(); cl.run(); &#125;&#125; ##三、接口和抽象类的区别尽管接口和和抽象类有很多相似处，都是用来被继承或被实现，但也有区别，下面从方式的实现，构造器，访问修饰符，多继承，效率等方面进行比较:| 参数 | 抽象类 | 接口 || :——– | ——–:| :–: || 默认的方法实现 | 它可以有默认的方法实现 | 接口完全是抽象的,它根本不存在方法的实现 || 实现 | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。|子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 ||构造器 | 抽象类可以有构造器| 接口不能有构造器 ||修饰符 | 抽象方法可以有public、protected和default这些修饰符 | 接口方法默认修饰符是public。你不可以使用其它修饰符。 ||main方法 | 抽象方法可以有main方法并且我们可以运行它| 接口没有main方法，因此我们不能运行它。 ||多继承 | 抽象方法可以继承一个类和实现多个接口 | 接口只可以继承一个或多个其它接口||效率 | 它比接口速度要快 | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 ||添加新方法 | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。 | ##四、总结1.如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。2.如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。3.如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"}]},{"title":"jquery实现页面无限滚动插件","slug":"jquery实现页面无限滚动插件","date":"2015-11-07T11:28:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/07/jquery实现页面无限滚动插件/","link":"","permalink":"http://hanyuanzhen.com/2015/11/07/jquery实现页面无限滚动插件/","excerpt":"实现网页底部自动加载内容的插件很多，如jQuery ScrollPagination，jQuery Screw,Autobrowse;下面主要介绍Autobrowse的使用。","text":"实现网页底部自动加载内容的插件很多，如jQuery ScrollPagination，jQuery Screw,Autobrowse;下面主要介绍Autobrowse的使用。 一、插件概述 实现网页底部自动加载内容的插件很多，如，1、jQuery ScrollPaginationjQuery ScrollPagination plugin 是一个jQuery 实现的支持无限滚动加载数据的插件。地址：http://andersonferminiano.com/jqueryscrollpagination/他的demo下载：http://andersonferminiano.com/jqueryscrollpagination/jqueryscrollpagination.zip2.jQuery ScrewScrew (scroll + view) 是一个 jQuery 插件当用户滚动页面的时候加载内容，是一个无限滚动翻页的插件。官方地址：https://github.com/jasonlau/jQuery-ScrewAutobrowse jQuery Plugin 插件在用户滚动页面的时候自动通过 Ajax 加载更多内容，使用浏览器内置缓存。 AutoBrowse jQuery PluginAutobrowse jQuery Plugin 插件在用户滚动页面的时候自动通过 Ajax 加载更多内容，使用浏览器内置缓存。官方地址：https://github.com/msjolund/jquery-esn-autobrowse 二、插件使用说明下面介绍一下Autobrowse的使用：1.引入js依赖文件12&lt;script type=\"text/javascript\" src=\"../plugin/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../plugin/jquery.esn.autobrowse.js\"&gt;&lt;/script&gt; 2.定义HTML元素1234&lt;div class=\"full-dom\"&gt; &lt;ul class=\"list-y2\" id=\"activityList\"&gt; &lt;/ul&gt;&lt;/div&gt; 3.js定义 1234567891011121314151617$(\"#activityList\").autobrowse(&#123; url:function (offset) &#123; //请求服务器端地址 &#125;, template:function (data) &#123; //异步组装服务器端返回的数据 &#125;, itemsReturned:function (data) &#123; //返回服务端数据的长度 &#125;, offset:1, max:10000, loader:'' //加载的图标, useCache:false, //使用缓存 expiration:1,//过期时间 sensitivity: 2000 //触发下一页的差值 finished: function () &#123; $(this).append('&lt;p style=\"text-align:center\"&gt;加载完成，没 有更多活动了&lt;/p&gt;') &#125;//没有数据时的提示 &#125;); 从上可看出，autobrowse可以自定义参数，来触发页面底部自动加载数据的时间和内容，能带来好的用户体验。 三、依赖文件下载http://download.csdn.net/detail/xhwwc110/9244831","categories":[{"name":"前端插件","slug":"前端插件","permalink":"http://hanyuanzhen.com/categories/前端插件/"}],"tags":[{"name":"无限滚动插件","slug":"无限滚动插件","permalink":"http://hanyuanzhen.com/tags/无限滚动插件/"},{"name":"Autobrowse","slug":"Autobrowse","permalink":"http://hanyuanzhen.com/tags/Autobrowse/"}]},{"title":"Jcrop图像裁剪","slug":"Jcrop图像裁剪","date":"2015-11-06T11:28:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/06/Jcrop图像裁剪/","link":"","permalink":"http://hanyuanzhen.com/2015/11/06/Jcrop图像裁剪/","excerpt":"Jquey Jcrop是一款功能强大的图像裁剪插件，结合服务端的处理可实现图片裁剪，改变等功能。","text":"Jquey Jcrop是一款功能强大的图像裁剪插件，结合服务端的处理可实现图片裁剪，改变等功能。 一、Jcrop简介 Jquey Jcrop是一款功能强大的图像裁剪插件，结合服务端的处理可实现图片裁剪，改变等功能。 具有如下特点: 显示图像或块对象 支持图片的最大，最小值的设置 有交互性的API，包含动画 提供CSS样式的定义 支持IOS,android等平台 二、使用方法1.载入 CSS 文件 1&lt;link type=\"text/css\" rel=\"stylesheet\" href=\"../css/jquery.Jcrop.css\" /&gt; 2.载入 JavaScript 文件12&lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery.Jcrop.js\"&gt;&lt;/script&gt; 3.给 IMG 标签加上 ID1234&lt;div class=\"Preview-pic\" id=\"previewIcon\"&gt; &lt;img id=\"imgCrop\" class=\"imgCrop\" name=\"imgCrop\" width=\"300\" height=\"300\" border=\"0\" src=\"\"/&gt; &lt;/div&gt; 4.调用 Jcrop12345jcrop_api=$.Jcrop('#imgCrop',&#123; aspectRatio: 1, onChange: showCoords, // 选框改变时的事件 onSelect: showCoords // 选框选定时的事件 &#125;); 三、使用实例 1.下载Jcop的依赖文件，下载地址如下: http://deepliquid.com/content/Jcrop.html,将css和js文件引入项目中 。 2.页面定义123456789101112131415&lt;header class=\"head-revision-top clearfix\"&gt; &lt;h4 class=\"fl\" id=\"sysField\"&gt; &lt;a href=\"\"&gt;系统头像&lt;/a&gt; &lt;/h4&gt; &lt;p class=\"fr head-revision-file\"&gt; &lt;input class=\"head-revision-input\" type=\"file\" accept=\"image/*\" name=\"uploadFile\" id=\"uploadFile\" onchange=\"checkImgType(this);\" /&gt; &lt;/p&gt;&lt;/header&gt;&lt;div class=\"head-revision mt20 clearfix\" id=\"uploadIcon\"&gt; &lt;div class=\"Preview-pic\" id=\"previewIcon\"&gt; &lt;img id=\"imgCrop\" class=\"imgCrop\" name=\"imgCrop\" width=\"300\" height=\"300\" border=\"0\" src=\"\"/&gt; &lt;/div&gt; 3.js实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150 var firstFlag = false,count=0;var jcrop_api, boundx, boundy;$(function()&#123; $('#userIconBtn').click(function() &#123; var x = $(\"#x\").val(); var y = $(\"#y\").val(); var w = $(\"#w\").val(); var h = $(\"#h\").val(); if (w == 0 || h == 0) &#123; alert(\"您还没有选择图片的剪切区域,不能进行剪切图片!\"); return; &#125;else&#123; $.ajax(&#123; url: '', data: $('#uploadIconForm').serialize(), type: \"POST\", beforeSend: function() &#123; &#125;, success: function() &#123; // 提交成功，刷新页面 //location.reload(true); window.location.href=\"\"; &#125; &#125;); &#125; &#125;);&#125;);/**检查图片上传类型*/ function checkImgType(obj)&#123; //更换头像销毁原有的jcrop if(count&gt;=1)&#123; firstFlag=false; jcrop_api.destroy(); &#125; var uploadFile = ''; //获取图片的全路径 var imgFilePath = getImgFullPath(obj); var endIndex = imgFilePath.lastIndexOf(\"\\\\\"); var lastIndex = imgFilePath.length-endIndex-1; if (endIndex != -1) uploadFile= imgFilePath.substr(endIndex+1,lastIndex); else uploadFile = imgFilePath; var tag = true; endIndex = imgFilePath.lastIndexOf(\".\"); if (endIndex == -1) tag = false; var ImgName = imgFilePath.substr(endIndex+1,lastIndex); ImgName = ImgName.toUpperCase(); if (ImgName !=\"GIF\" &amp;&amp; ImgName !=\"JPG\" &amp;&amp; ImgName !=\"PNG\" &amp;&amp; ImgName !=\"BMP\")&#123; tag=false; &#125; if (!tag) &#123; alert(\"上传图片的文件类型必须为: *.gif,*.jpg,*.png,*.bmp,请重新选择!\") Upload.clear(obj); return false; &#125;else&#123; count++; $.ajaxFileUpload(&#123; url: \"user!uploadFile\", //需要链接到服务器地址 secureuri:false, fileElementId:\"uploadFile\", //文件选择框的id属性 dataType: \"json\", //服务器返回的格式，可以是json success: function(data)&#123; if(data.resultCode=1)&#123; $(\"#imgCrop\").attr(\"src\",data.resultInfo); $(\"#imgCrop\").attr(\"width\",data.width); $(\"#imgCrop\").attr(\"height\",data.height); $(\"#width\").val(data.width); $(\"#height\").val(data.height); $(\"#imgFileExt\").val(data.imgFileExt); $(\"#oldImgPath\").val(data.oldImgPath); jcrop_api=$.Jcrop('#imgCrop',&#123; aspectRatio: 1, onChange: showCoords, // 选框改变时的事件 onSelect: showCoords // 选框选定时的事件 &#125;); &#125;else&#123; alert(\"系统连接有误,请重新上传或连接管理员\"); &#125; jcrop_api.enable(); jcrop_api.setImage(data.resultInfo); jcrop_api.animateTo([0,0,200,200]); jcrop_api.setOptions(&#123; allowResize:true, allowSelect: false, allowMove:true &#125;); //获取图片的实际尺寸 var bounds=jcrop_api.getBounds(); boundx=bounds[0]; boundy=bounds[1]; &#125; &#125;); &#125;&#125; function getImgFullPath(obj) &#123; if (obj) &#123; //ie if (window.navigator.userAgent.indexOf(\"MSIE\") &gt;= 1) &#123; obj.select(); return document.selection.createRange().text; &#125; //firefox else if (window.navigator.userAgent.indexOf(\"Firefox\") &gt;= 1) &#123; if (obj.files) &#123; return obj.files.item(0).getAsDataURL(); &#125; return obj.value; &#125; return obj.value; &#125; &#125; function showCoords(c) &#123; $('#x').val(c.x); $('#y').val(c.y); $('#x2').val(c.x2); $('#y2').val(c.y2); $('#w').val(c.w); $('#h').val(c.h); if(!firstFlag)&#123; exchange(); &#125; showPreview(c);&#125; function exchange()&#123; firstFlag = true; $('#preview').attr(\"src\", $('#imgCrop').attr(\"src\")); &#125;function showPreview(coords) &#123; if (parseInt(coords.w) &gt; 0) &#123; var rx = 200 / coords.w; var ry = 200 / coords.h; $('#preview').css(&#123; width:Math.round(200/ coords.w * boundx) + 'px', //200 为预览div的宽和高 height:Math.round(200/ coords.h * boundy)+ 'px', marginLeft : '-' + Math.round(rx * coords.x) + 'px', marginTop : '-' + Math.round(ry * coords.y) + 'px' &#125;); &#125;&#125; 4.服务器处理（java）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public String uploadFile() &#123; int result = Constant.RET_OK; String resultUrl = \"\"; String imgUploadPath = \"\"; // 图片初始化高度与宽度 String width = null; String height = null; int imgWidth = 0; int imgHeight = 0; SimpleDateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmss\"); String userWebAppPath = getWebAppPath(); /** 检查是否有图片上传文件夹 */ FileUtil.checkImageDir(userWebAppPath); try &#123; UserPOJO userSession = (UserPOJO) getSession(Constant.USERLOGINSESSION); if (null == userSession) &#123; result = Constant.ISSESSIONERROR; &#125; // 指定图片宽度和高度 width = getRequest().getParameter(\"width\"); if (null == width || \"\".equals(width)) &#123; width = \"300\"; &#125; height = getRequest().getParameter(\"height\"); if (null == height || \"\".equals(height)) &#123; height = \"300\"; &#125; imgWidth = Integer.parseInt(width); imgHeight = Integer.parseInt(height); List&lt;File&gt; files = getUploadFile(); if (files != null &amp;&amp; files.size() &gt; 0) &#123; for (int i = 0; i &lt; files.size(); i++) &#123; File userFile = files.get(i); try &#123; String filePath = FileUtil.saveLocalImg(userFile, userWebAppPath + \"\\\\\" + getUploadFileFileName().get(0)); BufferedImage src = ImageIO.read(new File(filePath)); // 读入文件 int imgSrcWidth = src.getWidth(); // 得到源图宽 int imgSrcHeight = src.getHeight(); // 得到源图长 // 重新指定大小 if (imgSrcWidth &gt;= imgSrcHeight) &#123; imgWidth = imgSrcWidth &gt; 300 ? 300 : imgSrcWidth; imgHeight = (int) (imgWidth * (float) imgSrcHeight / (float) imgSrcWidth); imgHeight = imgHeight &lt; 200 ? 200 : imgHeight; &#125; else &#123; imgHeight = imgSrcHeight &gt; 300 ? 300 : imgSrcHeight; imgWidth = (int) (imgHeight * (float) imgSrcWidth / (float) imgSrcHeight); imgWidth = imgWidth &lt; 200 ? 200 : imgWidth; &#125; // 按照图片的设置大小生成 ImageCut.scale(src, userFile, imgWidth, imgHeight); log.info(\"创建\" + imgWidth + \"*\" + imgHeight + \"图片成功\"); // 上传图片到图片服务器并获得访问地址 FileInputStream fis = new FileInputStream(userFile); byte[] fileBytes = new byte[fis.available()]; fis.read(fileBytes); fis.close(); resultUrl = FileUtil.getImageUrl(FileUtil.getExtName(this.getUploadFileFileName().get(0)), fileBytes); // 将远程服务器得到的文件保存到该服务器 String newFileName = df.format(new Date()) + \"_\" + new Random().nextInt(1000) + \".\" + FileUtil.getExtName(this.getUploadFileFileName().get(0)); imgUploadPath = IMGROOT + newFileName; FileUtil.saveImageToLocal(resultUrl, userWebAppPath + newFileName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); result = Constant.SYSTEM_ERROR; &#125; Map&lt;Object, Object&gt; infoMap = new HashMap&lt;Object, Object&gt;(); infoMap.put(Constant.RESULT_CODE_KEY, result); infoMap.put(Constant.RESULT_INFO, resultUrl); infoMap.put(\"width\", imgWidth); infoMap.put(\"height\", imgHeight); infoMap.put(\"oldImgPath\", imgUploadPath); infoMap.put(\"imgFileExt\", FileUtil.getExtName(this.getUploadFileFileName().get(0))); JSONObject json = JSONObject.fromObject(infoMap); writeJSON(json.toString()); return null;&#125; 四、API接口及参数说明http://code.ciaoca.com/jquery/jcrop/ 五、实现效果","categories":[{"name":"前端插件","slug":"前端插件","permalink":"http://hanyuanzhen.com/categories/前端插件/"}],"tags":[{"name":"图像裁剪","slug":"图像裁剪","permalink":"http://hanyuanzhen.com/tags/图像裁剪/"},{"name":"Jcrop","slug":"Jcrop","permalink":"http://hanyuanzhen.com/tags/Jcrop/"}]},{"title":"swiper图片轮播插件","slug":"swiper图片轮播插件","date":"2015-11-05T08:28:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/11/05/swiper图片轮播插件/","link":"","permalink":"http://hanyuanzhen.com/2015/11/05/swiper图片轮播插件/","excerpt":"实现图片轮播的幻灯片的效果的插件有很多，如touchsiler,Swiper，silerbox等等，各有独自的API和自定义效果。下面要说的是关于swiper的使用。","text":"实现图片轮播的幻灯片的效果的插件有很多，如touchsiler,Swiper，silerbox等等，各有独自的API和自定义效果。下面要说的是关于swiper的使用。 一、swiper简介 实现图片轮播的幻灯片的效果的插件有很多，如touchsiler,Swiper，silerbox等等，各有独自的API和自定义效果。下面要说的是关于swiper的使用。 Swiper 是一款免费以及轻量级的移动设备触控滑块的js框架，使用硬件加速过渡（如果该设备支持的话）。主要使用于移动端的网站、移动web apps，native apps和hybrid apps。 主要是为IOS而设计的，同时，在Android、WP8系统也有着良好的用户体验，Swiper从3.0开始不再全面支持PC端。 因此，如需在PC上兼容更多的浏览器，可以选择Swiper2.x（甚至支持IE7）。 中文官网：[http://www.swiper.com.cn/] 二、默认参数说明如:var swiper = new Swiper(‘.swipe3’, { spaceBetween: 10, centeredSlides: false, slidesPerView : 3,//设置slider容器能够同时显示的slides数量(carousel模式) initialSlide : 0,//设定初始化时slide的索引。 autoplay: 5000,//播放的间隔时间 loop: true,//是否循环播放 autoplayDisableOnInteraction: false,//用户操作swiper之后，是否禁止autoplay。默认为true：停止 }); 三、使用教程1.首先加载插件，需要用到的文件有swiper.min.js和swiper.min.css文件。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link rel=\"stylesheet\" href=\"path/to/swiper.min.css\"&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=\"path/to/swiper.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果你的页面加载了jQuery.js或者zepto.js，你可以选择使用更轻便的swiper.jquery.min.js。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ... &lt;link rel=\"stylesheet\" href=\"path/to/swiper.min.css\"&gt;&lt;/head&gt;&lt;body&gt; ... &lt;script src=\"path/to/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"path/to/swiper.jquery.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.HTML内容。 12345678910111213141516&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt;&lt;/div&gt; 导航等组件可以放在container之外3.你可能想要给Swiper定义一个大小，当然不要也行。.swiper-container { width: 600px; height: 300px;}4.初始化Swiper 12345678910111213141516&lt;script&gt; var mySwiper = new Swiper ('.swiper-container', &#123; direction: 'vertical', loop: true, // 如果需要分页器 pagination: '.swiper-pagination', // 如果需要前进后退按钮 nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', // 如果需要滚动条 scrollbar: '.swiper-scrollbar', &#125;) &lt;/script&gt; 如果不能写在HTML内容的后面，则需要在页面加载完成后再初始化。 123456789101112&lt;script type=\"text/javascript\"&gt;window.onload = function() &#123; ...&#125;&lt;/script&gt;或者这样（Jquery和Zepto）&lt;script type=\"text/javascript\"&gt;$(document).ready(function () &#123; ...&#125;)&lt;/script&gt; 5.完成。恭喜你，现在你的Swiper应该已经能正常切换了，如果没有，你可以参考下这个测试包。现在开始添加各种选项和参数丰富你的Swiper，开启华丽移动前端创作之旅。 插件下载地址:1.http://www.swiper.com.cn/download/index.html2.http://download.csdn.net/detail/xhwwc110/9244457","categories":[{"name":"前端插件","slug":"前端插件","permalink":"http://hanyuanzhen.com/categories/前端插件/"}],"tags":[{"name":"图片轮播","slug":"图片轮播","permalink":"http://hanyuanzhen.com/tags/图片轮播/"},{"name":"swiper","slug":"swiper","permalink":"http://hanyuanzhen.com/tags/swiper/"}]},{"title":"python基础详解","slug":"python基础详解","date":"2015-10-22T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/10/22/python基础详解/","link":"","permalink":"http://hanyuanzhen.com/2015/10/22/python基础详解/","excerpt":"Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，能简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的很多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。","text":"Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，能简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的很多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。 一、语句和语法python具有一些基本的规则和特殊字符，说明如下： #:用于注释内容 \\n:用于分隔符 \\:继续上一行 如 if(A==1) and \\ (B==2): return 特殊情况为:&apos;&apos;&apos;(三引号下的内容可跨行) 2.给一些变量赋值 ;将两个语句连接在一行中 如:import sys;x=&apos;foo&apos; sys.stdout.write(x) 此方式不提倡 :将代码块的头和体分开 缩进相同的一组语句构成代码块，如if while def class等 以(:)结束 ，则该行后的一行或多行称为代码组 代码块(语句):用缩进的方式体现 py文件是以模块的方式组织 每一个python脚本可以称为一个模块，以文件的方式存储。模块的中内容可以是可直接执行脚本，一些类库函数 或被导入的调用 二、变量 (1)赋值操作(注意pyton赋值不是将一个值赋给另一个变量 而是将该对象的引用赋值给变量) 如 aList=[1,2,3,&apos;abc&apos;,23.44] aStr=&apos;hello&apos; (2)增量操作 等号和一个算术操作符构成一个增量操作符 如x+=1 -= %= **= 但python不支持类似x++ 或x--等自增或自减 (3)多重赋值 如x=y=z=1 另一种为将多个变量同时赋值.如 x,y,z=1,3,&apos;abc&apos; 交换两个变量的赋值可以通过多元赋值实现 如:x,y=1,2 x,y=y,x **标识符** 标识符是有效字符串的集合 其中有一部分构成保留字 不能用于其他用途 pyhon标识符规则: 1.第一个字符必须是字母或下划线 2.其他字符需是字母，下划线或数字组成 3.大小写敏感 (2)关键字 (3)内建 (4)专用下划线标识符 python可以用下划线作为变量的前缀或后缀指定特殊变量符，说明如下 1._xxx 不要from module import * 导入 2._XXX_ 系统定义的名字 3._xxx 类中的私有变量 在模块或类外不可以使用 三、编程风格 1.注释 2.文档 python 提供了一种机制，可以用_doc_特殊变量 动态获取文档内容 ，在类 模块或函数声明中第一个没有赋值的字符串可用属性obj._doc_来访问 3.缩进 (2).模块的结构和布局 用模块组织python的代码 将其应用到每一个文件，如 1.起始行 2.模块文档 说明模块的功能和全局变量的含义。可以通过module._doc_访问 3.模块导入 4.变量定义 次变量定义为全局变量，在本模块的所有函数都可以使用，但通常使用局部变量代替全局变量 5.类定义 (类的文档变量是class._doc_) 6.函数定义(函数的文档变量是function._doc_) 7.主程序 无论是被导入的模块还是作为直接执行的脚本，此部分都会执行，是根据执行模式调用不同的函数 python可以用如下方式检测该模块是被导入的模块还是被直接执行 A.若模块是被导入，__name__的值为模块的名字 B.若模块是直接执行,__name__的值为__main__ 四、内存管理变量无须事先声明 变量无须指定类型 不需要关心内存回收 del语句可直接释放资源 五、入门例子12345678910111213141516171819202122232425262728293031#!/usr/bin/env python'makeTextFile.py -- create text file'import os# get filenamewhile True: fname = raw_input('Enter file name: ') if os.path.exists(fname): print\"*** ERROR: '%s' already exists\" % fname else: break# get file content (text) linesall = []print \"\\nEnter lines ('.' by itself to quit).\\n\"# loop until user terminates inputwhile True: entry = raw_input('&gt; ') if entry == '.': break else: all.append(entry)# write lines to file with NEWLINE line terminatorfobj = open(fname, 'w')fobj.write('\\n'.join(all))fobj.close()print 'DONE!' 六、相关的模块和开发工具调试器:pdb记录器:logging性能测试器:profile hotshot","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"}]},{"title":"主流HTML5游戏开发引擎的分析和对比","slug":"主流HTML5游戏开发引擎的分析和对比","date":"2015-10-22T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/10/22/主流HTML5游戏开发引擎的分析和对比/","link":"","permalink":"http://hanyuanzhen.com/2015/10/22/主流HTML5游戏开发引擎的分析和对比/","excerpt":"HTML 5是近十年来Web开发标准最巨大的飞跃。和以前的版本不同，HTML 5并非仅仅用来表示Web内容，它的新使命是将Web带入一个成熟的应用平台，在HTML 5平台上，视频，音频，图象，动画，以及同电脑的交互都被标准化","text":"HTML 5是近十年来Web开发标准最巨大的飞跃。和以前的版本不同，HTML 5并非仅仅用来表示Web内容，它的新使命是将Web带入一个成熟的应用平台，在HTML 5平台上，视频，音频，图象，动画，以及同电脑的交互都被标准化 一、引擎说明本文主要选取了Construct2、ImactJS、LimeJS、GameMaker、CreateJS、lycheeJS、Crafty、three.js、melonJS、Turbulenz、Quintus、Cocos2d-html5等进行了简要介绍和对比，主要是根据网上的资料整理而成。主流框架对比 Construct2Construct 2是一个运行于Windows平台的游戏制作工具，它可以让没有任何编程基础的用户在短时间内不写一行代码快速开发出一款可运行于所有平台（Windows、Mac、Linux、Android、iOS等）的游戏。免费版可以将游戏导出成HTML5。收费版本分为个人版（79英镑）和企业版（259英镑），可以导出所有平台的版本，同时提供了更多的特效和音乐。如果使用该工具盈利超过5000美元，需要升级到企业版。 优点： 简单易用，可实时运行游戏 强大的事件系统，可以不通过写代码来控制游戏逻辑 提供了可编程扩展的接口 提供了大量特效，支持物理效果 支持所有平台 完整的文档以及社区支持 缺点：不如直接写代码灵活 参考资料： 官方网站 Construct 2 vs. Javascript ImpactJSImpactJS是一个基于JavaScript的HTML5游戏引擎，同时支持PC和移动平台浏览器。它是目前除了Construct2之外最受欢迎的HTML5游戏引擎，使用需要支付99美元。 优点： 提供了灵活的关卡编辑器，可以快速构建游戏地图 提供了强大的调试工具 提供了Ejecta可以将JavaScript的执行结果通过OpenGL渲染出来，可以在iOS平台上获得与原生应用相近的效率 文档齐全，有两本专门介绍ImpactJS开发的书 支持物理效果 支持自己编写插件来扩展 App Store游戏 Biolab Disaster Drop JS LimeJSLimeJS是一个基于Google Closure Library开发的HTML5游戏框架，继承了Closure代码易读易懂、架构清楚的特性。同时提供了游戏中各种通用实体的封装，如Director、Scene、Layer、Event和Animation等，与Cocos2d的API类似。它是由Digital Fruit公司创建。 优点： 基于Apache协议的开源框架 功能强大，文档齐全，与ImactJS类似 支持物理效果 与Cocos2d的API类似，容易上手 缺点：依赖于Google Closure GameMakerGameMaker与Construct 2类似，都是一个游戏制作工具，可以导出到各个平台运行，分为免费版、标准版（49.99美元）、专业版（99.99美元）和大师版（799.99美元）。其中免费版只能导出Mac和Windows版本，导出HTML5需要大师版或者专业版（再额外支付99.99美元）。 优点和缺点：优势与Construct2类似，但性价比不如Construct2高 CreateJS(EaselJS)CreateJS是Adobe官方赞助的开源开发框架，它大部分API都是基于Flash原有的API来模仿实现的，并且官方提供了直接把Flash动画转成JS数据包的工具，调用起来很方便。CreateJS提供了若干开发套件及工具，分别是：EaselJS（负责图形、事件、触控、滤镜等功能）、TweenJS（补间动画）、SoundJS（音频控制）、PreloadJS（文件加载）和Zoë（生成图片精灵及动画数据）。 优点： Flash开发者很容易上手 提供了Flash转html5的工具，可以将部分Flash代码进行转换再修改 基于MIT协议的开源框架 类库设计非常独立，包含不同的模块，可选择性使用 lycheeJSlycheeJS是一个环境独立的JavaScript游戏引擎，可以在任何支持JavaScript的环境中运行。它的理念是做最快的JavaScript游戏引擎。 优点： 同时支持PC（Firefox、Chrome、Opera、Safari、IE）和移动平台（WebKit、Chrome、Firefox、Safari）的浏览器 提供了CDN、WebSockets、SPDY、HTTP2.0以及游戏截图的支持 提供了可以直接导出第三方（Facebook、AppStore、Google Play Store）资源包来发布 基于MIT协议的开源框架 CraftyCrafty是一个体积小、简单、轻量级的2D的HTML5游戏引擎，它提供了通过Canvas或DOM来绘制实体，提供了精灵Map以及SAT高级碰撞监测支持。它是由个人（Louis Stowasser）创建，同时由Github上的一些开发者共同开发。 优点 体积小 轻量级引擎，不会受到框架的太多束缚 同时支持PC和移动平台浏览器 three.jsThree.js是一个轻量级的JavaScript库，用于在浏览器上创建和显示3D图形。它可以同时使用Canvas、SVG或WebGL进行绘制。 优点和缺点：支持3D，但是不适合做2D游戏 melonJSmelonJS是melonJS团队对Javascript热情以及开发经验的结晶，是一个简单、免费、而且独立的类库。 优点 轻量级的2D引擎 支持所有主流的PC和移动平台浏览器 支持使用Tiled map editor来创建和编辑地图 支持多声道音频 基于MIT协议的开源框架 TurbulenzTurbulenz是一个开源的HTML5游戏引擎，提供了可以运行在Windows、MacOS、Linux上的SDK，允许开发人员创建高质量和硬件加速的2D、3D游戏。包括以下功能：异步资源加载、进行特效和粒子渲染、支持物理效果、碰撞检测以及动画、3D音效支持、支持网络交互以及社交网络分享、场景和资源的管理。 优点： 功能强大，同时支持2D和3D 基于MIT协议的开源引擎 QuintusQuintus是一个容易上手、轻量级、且模块化的HTML5游戏引擎。它引用面向对象的思想来进行HTML5游戏开发，同时依赖于jQuery来提供事件处理机制和元素选取操作。 缺点 依赖于jQuery 目前引擎仍处于初级阶段，还很不成熟 Cocos2d-html5Cocos2d-html5是一款基于Cocos2d-x API的2D开源免费HTML5游戏引擎。它目前通过canvas进行渲染，将来会支持WebGL。它由国内Cocos2d-x核心团队主导开发和维护，行业领袖、HTML5大力推动者Google为这个项目提供支持。同时，Zynga、Google等大公司的工程师也参与到它的设计工作中。 优点： 与Cocos2d的API类似，容易上手 中文文档齐全，资料丰富 基于MIT协议的开源引擎 二、各框架具体参数对比 各HTML5游戏框架对比HTML5 Game Engines List of JS Game Engines 对于Crafty、Lime、Frozen、Melon、Impact、Quintus框架，可以在Breakouts上查看用这些引擎开发同一个游戏的效果以及代码风格。Breakouts中使用到的特性包括碰撞检测、精灵动画、音效、地图、场景切换、交互、文字渲染、移动平台支持。 以上各引擎中，除了Construct2、ImpactJS、GameMaker是收费的之外，其他引擎都是免费并且开源的。对于开源引擎，我们可以从Github上面的关注度了解到该引擎的流行程度，关注的人越多，遇到问题越容易解决。同时一般来说，项目开发者越多，版本更新越快；项目的进行时间越长则越成熟。下面将对各开源引擎的开发者人数、项目启动时间、关注度进行对比。Game Engine Github commits Github contributors Start time Github Star Github ForkLimeJS 532 22 2011.1.19 1091 187EaselJS 784 15 2011.1.23 2758 650lycheeJS 4 1 2012.9.5 110 20Crafty 1182 67 2010.11.5 993 225three.js 6409 198 2010.3.23 12691 2816melonJS 1287 15 2011.4.11 643 137Turbulenz 736 12 2013.4.26（最近才开源） 1522 207Quintus 118 11 2012.8.4 450 89Cocos2d-html5 2706 39 2012.1.28 735 303 三、总结以上各引擎中，Construct2、ImpactJS、GameMaker三个是收费的，其中Construct2与GameMaker更像一个游戏开发工具，可以实现不用写一行代码来制作游戏，更适合于没有编程基础的人使用。而ImpactJS作为一个高质量的框架，且易于扩展，虽然是收费的，但是物有所值。 开源引擎中，three.js是最火的，但是仅限于开发3D游戏。其次是CreateJS，由Adobe官方赞助且采用Flash类似的API以及模块化开发，是Flash开发者以及将Flash游戏转换成html5不可多得的选择。Turbulenz虽然开源时间比较晚，但颇有后来者居上的趋势，由于其对2D和3D的同时支持，是同时开发2D和3D游戏的最佳选择。LimeJS与Crafty相比的优势在于有一个公司进行维护，相比个人要更稳定，但是需要依赖于Google Closure，也使之成为一个重量级的框架。Crafty体积小、轻量级，更适合于小游戏的开发。Cocos2d-html5作为国产框架的一个优势在于中文文档和教程多，且得到了Google的支持，但相比ImpactJS、CreateJS仍不够成熟。melonJS、Quintus、lycheeJS的开发者和使用者都较少，相关文档和教程也相对少，还有待观察。 参考资料 JavaScript Game Engine Comparison 转自:http://blog.csdn.net/zhaoxy_thu/article/details/11867123","categories":[{"name":"HTML5开发","slug":"HTML5开发","permalink":"http://hanyuanzhen.com/categories/HTML5开发/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://hanyuanzhen.com/tags/HTML5/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://hanyuanzhen.com/tags/游戏引擎/"}]},{"title":"核心java系列——线程（二）","slug":"核心java系列——线程（二）","date":"2015-10-21T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/10/21/核心java系列——线程（二）/","link":"","permalink":"http://hanyuanzhen.com/2015/10/21/核心java系列——线程（二）/","excerpt":"在大多数实际应用中，常常存在两个或两个以上的线程共享对同一数据的存储。如果多个线程去对同一对象的数据进行修改，则会引起线程竞争资源，导致数据被修改错误的问题，比如在ATM机上取款，多个用户对同一账户进行操作就会很容易发生。所以下面分析如何解决多线程共享资源引起竞争导致数据破坏问题。","text":"在大多数实际应用中，常常存在两个或两个以上的线程共享对同一数据的存储。如果多个线程去对同一对象的数据进行修改，则会引起线程竞争资源，导致数据被修改错误的问题，比如在ATM机上取款，多个用户对同一账户进行操作就会很容易发生。所以下面分析如何解决多线程共享资源引起竞争导致数据破坏问题。 一、锁的原理java中为每一个对象都提供了锁机制，用synchronized关键字修饰，它可以修饰方法和代码块。当一个对象获得该锁时，只能充许一个线程对该对象进行操作，其他线程处于等待状态，直到该线程释放锁。锁时可以重复利用的，锁有一个持有计数器来记录被利用的情况。线程可以根据计数器去加锁和释放锁。条件对象可以理解为临界区，线程只有在满足某一条件后才能使用它，一个锁对象可以有一个或多个相关的条件对象。以下为同步实例的实现: 1234567891011121314151617181920212223public class FooThread extends Thread &#123; private int x=100; public FooThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for(int i=0;i&lt;4;i++)&#123; x=this.sub(x, 30); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" : 当前的x值= \" +x); &#125; &#125; public synchronized int sub(int x,int y)&#123; return x=x-y; &#125;&#125; 二、内部锁内部锁将类的相关静态方法加上synchronized关键字,比如Bank类有一个静态同步的方法，那么当该方法被调用时，Bank.class将会被调用对象锁住，则其他线程无法再调用该类中的对象和其他同步的静态方法。内部锁也存在以下局限性：1.无法中断一个在视图获得锁的线程2.视图锁得锁事不能设定超时3.每一个锁仅有一个单一条件 三、同步阻塞如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行或运行为止。当考虑阻塞时，一定要注意哪个对象正被用于锁定：1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。volatile域若仅仅为了读写一个或两个实例域就使用同步，这对资源的开销过大。volatile是为实例域的访问提供了一种免锁机制，若声明一个实例域为volatile，则虚拟机就知道该域可能被其他线程并发访问。声明方式：private volatile boolean flag;还有一种用于原子整数，浮点数等的包装器类 Atomic可以应用于程序的并发访问，保证域的安全。总之，在以下三个条件下，域的并发访问是安全的:1.域是final 并且在在构造器调用完成后访问2.对域的访问由公有的锁进行保护3.域是volatile的 四、线程安全当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。即使是线程安全类，也应该特别小心，因为操作的线程是间仍然不一定安全。举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。程序说明如下: 123456789101112131415public class Demo4 &#123; @SuppressWarnings(\"unchecked\") private List resultList=Collections.synchronizedList(new LinkedList()); public synchronized void add(String param)&#123; resultList.add(param); &#125; public synchronized String remove()&#123; if(resultList.size()&gt;0)&#123; return (String) resultList.remove(0); &#125;else&#123; return null; &#125; &#125;&#125; 测试调用 123456789101112131415161718192021public static void main(String[] args) &#123; final Demo4 d=new Demo4(); d.add(\"test\"); class Test extends Thread&#123; @Override public void run() &#123; String param=d.remove(); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(param); &#125; &#125; Thread t1=new Test(); Thread t2=new Test(); t1.start(); t2.start(); &#125; 虽然集合对象 private List nameList = Collections.synchronizedList(new LinkedList());是同步的，但若remove()方法的synchronized去掉后，会引起线程不安全问题。 五、死锁锁和条件不能解决多线程中所有问题，当多个线程发生阻塞时，每个线程在等待另一线程释放资源会发生死锁，比如 账户A：200元，账户B:300元，A线程从账户A转移300到账户B,线程B从账户B转移400到账户A，因为A和B账户的余额都不足，无法进行转换，两个线程无法继续执行，而引发死锁状态。下面看一个发生死锁的实例: 123456789101112131415161718192021222324252627282930313233public class DeadLock implements Runnable &#123; int flag=1; final Object o1=new Object(); final Object o2=new Object(); @Override public void run() &#123; System.out.println(\"flag=\"+flag); if(flag==1)&#123; synchronized (o1) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; synchronized (o2) &#123; System.out.println(\"1\"); &#125; &#125;else if(flag==0)&#123; synchronized (o2) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; synchronized (o1) &#123; System.out.println(\"2\"); &#125; &#125; &#125;&#125; 程序说明: ◆ 一个线程（ThreadA）调用run()。 ◆ ThreadA在o1上同步，但允许被抢先执行。 ◆ 另一个线程（ThreadB）开始执行。 ◆ ThreadB调用run()。 ◆ ThreadB获得o2，继续执行，企图获得o1。但ThreadB不能获得o1，因为ThreadA占有o1。 ◆ 现在，ThreadB阻塞，因为它在等待ThreadA释放o1。 ◆ 现在轮到ThreadA继续执行。ThreadA试图获得o2，但不能成功，因为o2已经被ThreadB占有了。 ◆ ThreadA和ThreadB都被阻塞，程序死锁。","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://hanyuanzhen.com/tags/多线程/"}]},{"title":"SVN使用详解","slug":"SVN命令使用详解","date":"2015-10-20T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/10/20/SVN命令使用详解/","link":"","permalink":"http://hanyuanzhen.com/2015/10/20/SVN命令使用详解/","excerpt":"SVN全名Subversion，即版本控制系统。SVN与CVS一样，是一个跨平台的软件，支持大多数常见的操作系统。作为一个开源的版本控制系统,Subversion管理着随时间改变的数据。这些数据放置在一个中央资料档案库(repository)中。这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动。这样你就可以把档案恢复到旧的版本,或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件,其中包括了程序源码。","text":"SVN全名Subversion，即版本控制系统。SVN与CVS一样，是一个跨平台的软件，支持大多数常见的操作系统。作为一个开源的版本控制系统,Subversion管理着随时间改变的数据。这些数据放置在一个中央资料档案库(repository)中。这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动。这样你就可以把档案恢复到旧的版本,或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件,其中包括了程序源码。1.检出文件到服务器目录svn checkout path（path是服务器上的目录）例如：svn checkout svn://127.0.0.1/java/trunk/简写：svn co2、往版本库中添加新的文件svn add file例如：svn add HelloWorld.javasvn add *.java(添加当前目录下所有的java文件)3、将改动的文件提交到版本库svn commit -m “LogMessage“ [-N] [–no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)例如：svn commit -m “add test file for my test“ test.php简写：svn ci 4、加锁/解锁svn lock -m “LockMessage“ [–force] PATH例如：svn lock -m “lock test file“ HelloWorld.javasvn unlock PATH 5、更新到某个版本svn update -r m path例如：svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。svn update -r 200 HelloWorld.java(将版本库中的文件HelloWorld.java还原到版本200)svn update HelloWorld.java(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)简写：svn up 6、查看文件或者目录状态1）svn status path（目录下的文件和子目录的状态，正常状态不显示）【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】2）svn status -v path(显示文件和子目录状态)第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。简写：svn st7、删除文件svn delete path -m “delete test fle“例如：svn delete svn://127.0.0.1/java/trunk/src/HelloWorld.java -m “delete test file”或者直接svn delete HelloWorld.java 然后再svn ci -m ‘delete test file‘，推荐使用这种简写：svn (del, remove, rm)8、查看日志svn log path例如：svn log HelloWorld.java 显示这个文件的所有修改记录，及其版本号的变化9、查看文件详细信息svn info path例如：svn info HelloWorld.java10、比较差异svn diff path(将修改的文件与基础版本比较)例如：svn diff HelloWorld.javasvn diff -r m:n path(对版本m和版本n比较差异)例如：svn diff -r 200:201 HelloWorld.java简写：svn di11、将两个版本之间的差异合并到当前文件svn merge -r m:n path例如：svn merge -r 200:205 HelloWorld.java（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）12、SVN 帮助svn helpsvn help ci——————————————————————————以上是常用命令，下面写几个不经常用的——————————————————————————13、版本库下的文件和目录列表svn list path显示path目录下的所有属于版本库的文件和目录简写：svn ls14、创建纳入版本控制下的新目录svn mkdir: 创建纳入版本控制下的新目录。用法: 1、mkdir PATH… 2、mkdir URL…创建版本控制的目录。 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。15、恢复本地修改svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert: 用法: revert PATH… 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录16、代码库URL变更svn switch (sw): 更新工作副本至不同的URL。用法: 1、switch URL [PATH] 2、switch –relocate FROM TO [PATH…] 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。17、解决冲突svn resolved: 移除工作副本的目录或文件的“冲突”状态。用法: resolved PATH…注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。18、输出指定文件或URL的内容。svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://hanyuanzhen.com/categories/项目管理/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://hanyuanzhen.com/tags/版本控制/"},{"name":"SVN","slug":"SVN","permalink":"http://hanyuanzhen.com/tags/SVN/"}]},{"title":"核心java系列——线程（一）","slug":"核心java系列——线程（一）","date":"2015-10-20T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/10/20/核心java系列——线程（一）/","link":"","permalink":"http://hanyuanzhen.com/2015/10/20/核心java系列——线程（一）/","excerpt":"多线程是程序中有多个线程流在同时调度资源。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),一个线程可以创建和撤销另一个线程。","text":"多线程是程序中有多个线程流在同时调度资源。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),一个线程可以创建和撤销另一个线程。 一、简介 多线程是程序中有多个线程流在同时调度资源。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),一个线程可以创建和撤销另一个线程。 二、线程和进程1.进程是程序运行的实例，每一个进程都有自己的内存空间，包含内容和数据，不同进程间有相互独立的地址空间2.线程是CPU调度的基本单位，每一个线程都有顺序执行的，线程有共享资源和锁机制。3.两者区别和联系(1) 划分尺度:线程更小，所以多线程程序并发性更高;(2) 资源分配：进程是资源分配的基本单位，同一进程内多个线程共享其资源;(3) 地址空间：进程拥有独立的地址空间，同一进程内多个线程共享其资源;(4) 处理器调度：线程是处理器调度的基本单位;(5) 执行：每个线程都有一个程序运行的入口，顺序执行序列和程序的出口，但线程不能单独执行，必须组成进程， 一个进程至少有一个主线程。简而言之,一个程序至少有一个进程,一个进程至少有一个线程 三、线程的创建和启动线程创建有2中方式，一是实现Runnable接口，实现run()方法，然后创建一个Thread对象，将而是继承Thread类，实现run方法。两者都需要调用start()方法来启动线程。下面是两者方法的程序实现：1.继承Thread方式 12345678public class Demo1 extends Thread &#123; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125; &#125; 2.实现Runnable接口 12345678public class Demo2 implements Runnable &#123; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125; 四、线程的状态 线程运行时也有它的生命周期，线程会要经历开始（等待），运行，挂起（阻塞）和终止四种不同的状态，且四种状态可以由Thread来自由控制，下面给出Thread类控制各个状态的方法 1.线程开始 start()/run();2.线程挂起和唤醒 resume()/suspend()-已过时 sleep()；3.线程终止 stop()不建议使用 interupt()；4.其他与线程状态相关的方法isAlive():判断线程的状态是否还活着join():调用某线程的该方法，将当前线程与该线程“合并”，即等待该线程结束，再恢复当前线程的运行；yield():线程的让步，即让出当前线程的资源给其他线程使用。 状态图如下: 从图中可看出线程在建立后并不马上执行run方法中的代码，而是处于等待状态。线程处于等待状态时，可以通过Thread类的方法来设置线程不各种属性，如线程的优先级（setPriority）、线程名(setName)和线程的类型（setDaemon）等。 当调用start方法后，线程开始执行run方法中的代码。线程进入运行状态。可以通过Thread类的isAlive方法来判断线程是否处于运行状态。 当线程处于运行状态时，isAlive返回true， 当isAlive返回false时，可能线程处于等待状态，也可能处于停止状态。 注意:一但线程开始执行run方法，就会一直到这个run方法执行完成这个线程才退出。但在线程执行的过程中，可以通过两个方法使线程暂时停止执行。这两个方法是suspend和sleep。在使用suspend挂起线程后，可以通过resume方法唤醒线程。而使用sleep使线程休眠后，只能在设定的时间后使线程处于就绪状态（在线程休眠结束后，线程不一定会马上执行，只是进入了就绪状态，等待着系统进行调度）。在使用sleep方法时有两点需要注意： sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒(1,000,000纳秒等于1毫秒)。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。 在使用sleep方法时必须使用throws或try{…}catch{…}。因为run方法无法使用throws，所以只能使用try{…}catch{…}。当在线程休眠的过程中，使用interrupt方法中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下：publicstaticvoid sleep(long millis) throws InterruptedExceptionpublicstaticvoid sleep(long millis, int nanos) throwsInterruptedException 下面的举例为线程的合并的实现： A线程：1234567891011121314151617public class DemoA extends Thread &#123; public DemoA(String name)&#123; super(name); &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+\"-\"+i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; B线程:123456789101112131415161718192021public class DemoB extends Thread &#123; private Thread a; public DemoB(String name,Thread a)&#123; super(name); this.a=a; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+\"-\"+i); try &#123; Thread.sleep(1000); if(i==4)&#123; a.join(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 五、线程的属性线程的属性包括线程的优先级，守护线程等，明白线程的属性的作用，可以更灵活的设置线程的执行状态。 1.线程的优先级每一个线程都会对应一个优先级，默认情况下，新创建的线程会继承他父类的优先级。可以利用setPriority方法来修改线程的优先级的高低。修改的范围可以使MIN_PRIORITY和MAX_PRIORITY之间的任意级别下面为线程优先级设置的实例:定义的线程类:12345678910111213public class Demo3 implements Runnable &#123;@Overridepublic void run() &#123; for(int i=0;i&lt;20;i++)&#123; System.out.println(Thread.currentThread().getName()+\"-\"+i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#125; 线程优先级的设置: 12345678910111213//最小级别 Thread t1=new Thread(new Demo3()); t1.setPriority(Thread.MIN_PRIORITY); t1.start(); //正常 Thread t2 =new Thread(new Demo3()); t2.setPriority(Thread.NORM_PRIORITY); t2.start(); //最大级别 Thread t3 =new Thread(new Demo3()); t3.setPriority(Thread.NORM_PRIORITY); t3.start();&#125; 注意:在使用线程优先级时，应避免常犯的一个错误，假如高优先级的线程处于非活跃状态，低优先级的线程也不可能会执行，而资源调度线程时会在高优先级的线程中选择，这会是低优先级的线程饿死。 2.守护线程一般线程要转换为守护线程，可通过setDaemon(true);来设置，守护线程不会去访问固有资源，如文件，数据库等。其作用是为其他线程提供服务，如计时器的例子，守护线程可定时发送信号给实现计时的线程。 3.未捕获异常的处理器线程实现run方法时不会抛出可被检测的异常，而抛出的异常不能被检测到会导致线程终止，从而是程序死亡。java提供了一个未捕获异常的处理器，该处理器为Thread.UncaughTExceptionHandler接口的类。从JSE5.0后，提供了setUncaughTExceptionHandler方法为线程安装处理器.","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://hanyuanzhen.com/tags/多线程/"}]},{"title":"核心java系列——反射","slug":"核心java系统——反射机制","date":"2015-10-02T11:47:50.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/10/02/核心java系统——反射机制/","link":"","permalink":"http://hanyuanzhen.com/2015/10/02/核心java系统——反射机制/","excerpt":"反射是java中一种很强大的工具，能够动态分析java的类的能力。在运行状态中，对于任意一个类，通过反射都能知道这个类的属性和方法。这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。反射的概念是由Smith在1982年首次提出的。","text":"反射是java中一种很强大的工具，能够动态分析java的类的能力。在运行状态中，对于任意一个类，通过反射都能知道这个类的属性和方法。这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。反射的概念是由Smith在1982年首次提出的。 一，反射的简介反射是java中一种很强大的工具，能够动态分析java的类的能力。在运行状态中，对于任意一个类，通过反射都能知道这个类的属性和方法。这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。反射的概念是由Smith在1982年首次提出的。 二、反射的作用java的发射机制提供如下几个方面的作用:1.在运行时判断任意一个对象所属的类。2.在运行时构造任意一个类的对象。3.在运行时构造任意一个类所有的成员变量和方法。4.在运行时动态创建对象，从一个对象是属性拷贝到另一个对象相应的属性上。5.创建动态代理。 三、反射中常用的APIjava.lang.Class;java.lang.reflect.Constructor;java.lang.reflect.Field;java.lang.reflect.Method;java.lang.reflect.Modifier; 四、反射机制API的使用1.class类对象class类对象是反射机制的根源，由JVM生成（由于class类没有public方法，无法直接new 一个class对象），可以通过Object.getClass()获得class类型的对象下面介绍如何获取Class对象:A.通过getClass()方法获取，如String s=”agagad”;Class c=s.getClass();B通过Class.forName()获取（基本数据类型除外）。如Class c=Class.forName(“java.lang.String”);C.通过.class 如Class c=Person.class;Class c1=String.class等D.newInstance创建一个类对象 2.Field的作用Field可以描述一个类的成员变量，且可以通过getDeclareFields()获取类的所有成员变量。 Class c = Class.forName(“java.lang.Integer”); //获取所有的成员变量Field[] fs = c.getDeclaredFields();通过setAccessible()设置成员变量值可访问的实例如下: 123456789101112131415161718Class c=Class.forName(\"com.greekw.pojo.User\");System.out.println(\"User类的全路径类名\"+c.getName());System.out.println(\"User类的类名\"+c.getSimpleName());User user=new User();//获取类中所有的属性Field[] fields=c.getDeclaredFields();for(Field f:fields)&#123; //获取变量的修饰符 System.out.println(Modifier.toString(f.getModifiers())+\" \"); //获取变量的类型 System.out.println(f.getType().getSimpleName()); //获取变量名 System.out.println(f.getName()); //获取成员变量的值 String fName=f.getName(); f.setAccessible(true); System.out.println(fName+\"的值为:\"+f.get(user));&#125; 3.Method类Method类可描述类的所有方法，可以通过getDeclaredMethods()获取所有方法实例如下: 123456789101112131415161718//获取一个类的所有方法Class c=Class.forName(\"com.greekw.pojo.User\");Method[] methods=c.getDeclaredMethods();for(Method m:methods)&#123; //获取方法修饰符 System.out.println(Modifier.toString(m.getModifiers())+\" \"); //获取方法类型 System.out.println(m.getReturnType().getName()+\" \"); //获取方法名 System.out.println(m.getName()+\" \"); //获取方法的参数 Class[] params=m.getParameterTypes(); for(int i=0;i&lt;params.length;i++)&#123; Class pc=params[i]; System.out.println(pc.getSimpleName()+\",\"); &#125;&#125; 调用对象的方法,实现如下:12345678//调用对象的方法m.setAccessible(true);//设置对象的属性和方法是可访问的if(m.getName().equals(\"setIntValue\"))&#123; m.invoke(user, 50000);//修改属性的值&#125;if(m.getName().equals(\"setName\"))&#123; m.invoke(user, \"测试\");&#125; 4.关于instanceofinstanceof，用来判断某个对象是否是某种类型，计算结果是一个boolean类型的值如果一个对象继承了某个类，或实现了某些接口，那么这个对象都是属于哪些类型的实例如下:1234LittleDog ld=new LittleDog();if(ld instanceof LittleDog)&#123; System.out.println(ld的对象类型是LittleDog);&#125; 总之，java的反射机制是代码更加灵活，更容易体现面向对象的思想，在设计模式，配置文件读取，以及三大框架中都有用到，是一种构建工具类的利器。","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"},{"name":"反射","slug":"反射","permalink":"http://hanyuanzhen.com/tags/反射/"}]},{"title":"核心java系列——java的继承","slug":"核心java系列——java中继承","date":"2015-09-20T07:47:17.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/09/20/核心java系列——java中继承/","link":"","permalink":"http://hanyuanzhen.com/2015/09/20/核心java系列——java中继承/","excerpt":"继承是面向对象的一个重要特性，子类继承超类的方法和属性，可以使代码通用性强，封装性好。java中继承不支持多继承。下面分析继承的使用:","text":"继承是面向对象的一个重要特性，子类继承超类的方法和属性，可以使代码通用性强，封装性好。java中继承不支持多继承。下面分析继承的使用:一、类，超类和子类 继承是子类继承父类的属性和方法，比如在同一公司中，经理和普通职员存在待遇存在差异，比如他们都每月领取自己的薪水，而经理又会领到奖金。 则这可以用继承的概念去构造，子类也能去定义有差异的属性和方法。继承的格式是由关键字extends表示 如 class Employee extends Manager{ //属性和方法 } 通过extends 在已存在的类上派生出一个新类。已存在的类被称为超类，基类或父类，新类被称为派生类，子类。超类并不比子类存在更多的功能 1.子类可扩展超类没有的方法。 2.通用的方法常封装在父类中定义。 3.子类可以增加域，增加方法或覆盖父类的方法，但不能删除继承父类的域和方法。 super关键字:是指向父类的，可以拥有调用父类的属性和方法,如super(name)调用父类具有相同参数的构造器。 下面用如下几个方面继承中的几个概念： 1.继承层次 继承不只局限于一个层次，也可以多层次继承，有一个公共类派生出所有类的集合被称为继承的层次。 java不支持多继承。 2.多态 多态是指一个类可以有多种对象的引用，子类的每个对象也可是超类的对象，比如 Employee e=new Employee(); Employee e=new Manager(); 说明e即可父类Employee的引用，也是子类Manager的引用。 3.动态绑定 动态绑定是一种很重要的特性，可以在无须修改现存代码的基础上对程序进行扩展，比如生成一个新类B,变量e持有类B的引用，则对类中的非final,private,static修饰的方法，变量e都可调用。 4.阻止继承 父类中若有些方法不想被子类去继承，则可用final修饰，被称为不可扩展类。定义形式如下: final class Manager extends Employee{ } 类中的方法也可被修饰成final类.且此方法无法被继承。如 1234class Employee&#123; public final String getName()&#123; return name; &#125; 5.抽象类java中抽象是一个很重要的概念，抽象类和抽象方法的具体实现在其子类中，扩展抽象的方法有如下方式1.在子类中定义部分抽象方法或不定义抽象方法，则子类必须定义为抽象类。2.在子类定义全部的抽象方法，则子类不需要定义为抽象类。12345678910public abstract class Person &#123; private String name; public String getName() &#123; return name; &#125; public Person(String name)&#123; this.name=name; &#125; public abstract String getDescription();&#125; 1234567891011121314151617181920212223public class Employee extends Person &#123; public Employee(String name,double s,int year,int month,int day) &#123; super(name); salary=s; GregorianCalendar calendar=new GregorianCalendar(year, month-1, day); hday=calendar.getTime(); &#125; @Override public String getDescription() &#123; return String.format(\" an employee salry is $%.2f\", salary); &#125; private double salary; private Date hday; public double getSalary() &#123; return salary; &#125; public Date getHday() &#123; return hday; &#125; &#125; 6.受保护访问在类中常将属性修饰为private，方法修饰为public 可让子类不能访问超类中的私有属性。然而有时候超类的中的某个属性能被子类访问。则可将此属性修饰为protected.如Employee的name属性被protected修饰，子类可访问该属性，而不能访问其他属性。java中常用于控制可见性的4个修饰符:对本类可见-private对所有类可见-public对本包和所有子类可见-protected对本包可见-默认修饰符 二、Object-所有类的超类Object类所有java类的祖先，java中每个类都是由它扩展而来。如除基本类型不是对象，字符，布尔类型等都不是对象，所有数组类型，包括基本类型与对象数组都扩展于Object.Object中几个比较重要的方法，如equals,HashCode()和toString()等方法1.equals()是检测一个对象是否与另一个对象相同，在Object中，用于判断两个对象的引用是否相同，若引用相同，则认为两个对象是相等的。2.hashCode()方法是基于散列码，散列码是对象导出的一个整型值，若x,y是两个不同的对象，则x.hashCode()与y.hashCode()基本不会相同。 Equals()与hashCode()的定义必须一致，如x.equals(y)返回true,则x.hashCode()与y.hashCode()就必须有相同的值。 3.toString()返回对象值的字符串如 public string toString(){ return “Employee[name=”+name+”,salary=”+salary+”]” } 或public string toString(){ return getClass().getName()+”[name=”+name+”,salary=”+salary+”]” }","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"},{"name":"继承","slug":"继承","permalink":"http://hanyuanzhen.com/tags/继承/"}]},{"title":"python映像和集合类型","slug":"python映像和集合类型","date":"2015-05-10T11:41:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/05/10/python映像和集合类型/","link":"","permalink":"http://hanyuanzhen.com/2015/05/10/python映像和集合类型/","excerpt":"字典是python中唯一的映射类型，映射类型对象里哈希值和指向对象值是1:n的关系字典对象是可变的，可以认为是一个容器类型，能存储任意个python对象.","text":"字典是python中唯一的映射类型，映射类型对象里哈希值和指向对象值是1:n的关系字典对象是可变的，可以认为是一个容器类型，能存储任意个python对象. 字典一、字典的概述字典是python中唯一的映射类型，映射类型对象里哈希值和指向对象值是1:n的关系字典对象是可变的，可以认为是一个容器类型，能存储任意个python对象字典对象和序列对象的区别： 1.存储和访问数据的方式不同 2.映射类型的数据是无序排序 3.序列类型只能是数字类型的键，映射类型可以是其他类型的键 4.映射类型不要求用数字值做索引从一个容器中取对应的数据。可以用键直接映射到值（1）.字典的创建和赋值 创建字典只需要把一个字典赋值给一个变量 如:dict={‘name’:’earth’,’port’:80} 2.可用工厂方法dict()创建 如:fdict=dict(([‘x’,’1’],[‘y’,2])) 3.可用fromkeys()创建一个默认的字典 如:ddict ={}.fromkeys((‘x’,’y’),-1) (2):字典的访问1.循环其键值。如:for key in dict.keys(): print ‘key=%s,value=%s’ %(key,dict[key])2.用迭代器遍历字典,只需要知道字典的名字即可，如 dict={‘name’:’zhang’,’port’:80} for key in dict: print ‘key=%s,value=%s’ %(key,dict[key])3.获得字典的某个元素值 dict[key] 如:dict[name]=’zhang’ 若需检查字典是否有某一个key 可以用in 或not in 等(3):字典的更新1.添加一个新数据项或新元素 可以用字典变量名[key]=value；如 test={age:20.} test[name] =’student’ 则可得到tet={age:20,name:’student’}2.改变一个已存在的数据项 字典的修改和添加类似，可以用字典变量名[key]=新value3.删除一个已存在的数据项 del dict[key]:删除对应的键值，若用字典变量名则删除整个字典.如 del dict dict.clear() :清空字典内容 pop():删除对对应的值 二、映射类型操作符(1).字典的键查找操作符[] 1.键查找操作符是唯一用于字典类型的操作符，和序列中的单一元素切片相似 2.字典是用键查询，序列用索引做唯一参数或下标获取 (2).成员关系操作（in not in） in 和not in 检查某个键是否在字典中 如:name in dict 三、内建函数和工厂函数(1).标准类型函数 cmp() type() str(0(2).映射相关函数 dict():用于创建字典，若不提供参数，则会生成空字典。 如 dict(zip((‘x’,’y’),(1,2))) =&gt; {‘x’:1,’y’:2} 或者 dict([‘x’,1],[‘y’,2]) =&gt; {‘x’:1,’y’:2} len():返回所有元素的数目 如 dict={‘x’:1,’y’:2} 则len(dict)=2 hash()’ (3):内建方法 1.keys():返回一个列表包含字典所有的键 dict.keys() =&gt;[‘x’,’y’] 2.values():返回一个列表，包含字典所有的值 如dict.values =&gt; [1,2] 3.items():返回一个列表包含所有含有(键，值)的元组 如dict.items() =&gt; [(‘x’,1),(‘y’,2)] 4.update() 如dict.update(dict2) 将字典dict2的key-value添加到字典dict 如dict2={‘x’:1,’y’:2,’z’:3} dict.update(dict2) =&gt; {‘x’:1,’y’:2,’z’:3} 5.setdefault() 和set()类似，若字典不存在key 由dict[key]=default为它赋值 6.clear() 删除字典中所有元素 如 dict.clear() =&gt; {} 7.copy() 返回一个字典的副本 如dict2=dict.copy() =&gt; {‘x’:1,’y’:2} 四、字典的键 字典的键必须是不可变数据类型，如果用元组做键，那必须要保证元组内的对像也是不可变类型。可变数据类型对像不能做键。 集合一、集合类型set是不同元素组成的集合，python中的集合对象是一组无序排列的可hash的值。集合分为两种类型.可变集合(set)和不可变集合(frozenset)。可变集合可以删除或添加元素，不可变集合不充许;可变集合不是可 哈希的 不能用作字典的键,也不能用作其他集合中的元素,不可变集合真好相反(1)、集合的创建 主要有set()和frozenset()方法 如:s=set(‘abcd’) =&gt; set([‘a’,’b’,’c’,’d’]); frozenset(‘BOOK’) =&gt;frozenset([‘B’,’O’,’O’,’K’]) (2).集合的访问 可以遍历和检查某项元素是否是一个集合的元素 如: ‘K’ in s(3).更新集合 可以用集合内建方法进行添加，删除集合的成员 如: s.add(‘z’) s.update(‘pypj’) s-=set(‘pypj’) s.remove() (4).如何删除集合中的成员和集合 A.集合超出其作用范围 B.调用del将他们直接清除当前的名称空间二、集合类型操作符 set集合是无序的，不能通过索引和切片来做一些操作三、内建函数和内建方法 (1).内建函数: len():返回集合的基数 set()和frozenset()返回可变集合和不可变集合 若不提供参数则会生成空集合 (2).内建方法:可分为适用于所有的集合方法和适用于可变集合的方法 1.仅适用于可变集合的如下: s.update(t) s.add(obj) s.remove(obj) s.discard(obj) s.pop():删除集合s中的任意一个对象 s.clear() 删除集合s中的所有元素 本节例子实现:该例子用于模拟管理登录系统123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python#-*-coding:utf-8 -*-db = &#123;&#125;def newuser(): prompt = 'login desired' while True: name = raw_input(prompt) if db.has_key(name): prompt = 'name taken, try anothers' continue else: break pwd = raw_input('password:') db[name] = pwddef olduser(): name = raw_input('login: ') pwd = raw_input('passwd: ') passwd = db.get(name) if passwd == pwd: print 'welcome back',name else: print 'login incorrect'def showmenu(): prompt = '''(N)ew User Login(E)xisting User Login(Q)uitEnter choice:''' done = False while not done: chosen = False while not chosen: try: choice = raw_input(prompt).strip()[0].lower() except (EOFError, KeyboardInterrupt): choice = 'q' print '\\nyou picked:[%s]' %choice if choice not in 'neq': print 'invalid option, try again' else: chosen = True if choice == 'q' :done = True if choice == 'n' :newuser() if choice == 'e' :olduser()if __name__ == '__main__': showmenu()","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"},{"name":"映像和集合","slug":"映像和集合","permalink":"http://hanyuanzhen.com/tags/映像和集合/"}]},{"title":"redis 数据类型详解","slug":"redis 数据类型详解","date":"2015-04-02T11:28:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/04/02/redis 数据类型详解/","link":"","permalink":"http://hanyuanzhen.com/2015/04/02/redis 数据类型详解/","excerpt":"最近几年，业界不断涌现出很多各种各样的NoSQL产品，那么如何才能正确地使用好这些产品，最大化地发挥其长处，是我们需要深入研究和思考的问题，实际归根结底最重要的是了解这些产品的定位，并且了解到每款产品的tradeoffs，在实际应用中做到扬长避短，总体上这些NoSQL主要用于解决以下几种问题1.少量数据存储，高速读写访问。此类产品通过数据全部in-momery 的方式来保证高速访问，同时提供数据落地的功能， 实际这正是Redis最主要的适用场景。","text":"最近几年，业界不断涌现出很多各种各样的NoSQL产品，那么如何才能正确地使用好这些产品，最大化地发挥其长处，是我们需要深入研究和思考的问题，实际归根结底最重要的是了解这些产品的定位，并且了解到每款产品的tradeoffs，在实际应用中做到扬长避短，总体上这些NoSQL主要用于解决以下几种问题1.少量数据存储，高速读写访问。此类产品通过数据全部in-momery 的方式来保证高速访问，同时提供数据落地的功能， 实际这正是Redis最主要的适用场景。实际MySQL是适合进行海量数据存储的，通过Memcached将热点数据加载到cache，加速访问，很多公司都曾经使用过这样的架构，但随着业务数据量的不断增加，和访问量的持续增长，我们遇到了很多问题：1.MySQL需要不断进行拆库拆表，Memcached也需不断跟着扩容，扩容和维护工作占据大量开发时间。2.Memcached与MySQL数据库数据一致性问题。3.Memcached数据命中率低或down机，大量访问直接穿透到DB，MySQL无法支撑。4.跨机房cache同步问题。众多NoSQL百花齐放，如何选择最近几年，业界不断涌现出很多各种各样的NoSQL产品，那么如何才能正确地使用好这些产品，最大化地发挥其长处，是我们需要深入研究和思考的问题，实际归根结底最重要的是了解这些产品的定位，并且了解到每款产品的tradeoffs，在实际应用中做到扬长避短，总体上这些NoSQL主要用于解决以下几种问题1.少量数据存储，高速读写访问。此类产品通过数据全部in-momery 的方式来保证高速访问，同时提供数据落地的功能， 实际这正是Redis最主要的适用场景。2.海量数据存储，分布式系统支持，数据一致性保证，方便的集群节点添加/删除。3.这方面最具代表性的是dynamo和bigtable 2篇论文所阐述的思路。前者是一个完全无中心的设计，节点之间通过gossip方式传递集群信息，数据保证最终一致性，后者是一个中心化的方案设计，通过类似一个分布式锁服务来保证强一致性,数据写入先写 内存 和redo log，然后定期compat归并到磁盘上，将随机写优化为顺序写，提高写入性能。4.Schema free，auto-sharding等。比如目前常见的一些文档数据库都是支持schema-free的，直接存储json格式数据，并且支持auto-sharding等功能，比如mongodb。面对这些不同类型的NoSQL产品,我们需要根据我们的业务场景选择最合适的产品。 Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢? 如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点： 1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 2 、Redis支持数据的备份，即master-slave模式的数据备份。 3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis常用数据类型Redis最为常用的数据类型主要有以下：StringHashListSetSorted setpub/subTransactions在具体描述这几种数据类型之前，我们先通过一张图了解下Redis内部内存管理中是如何描述这些不同数据类型的： 首先Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示： type代表一个value对象具体是何种数据类型， encoding是不同数据类型在redis内部的存储方式， 比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int,如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:”123” “456”这样的字符串。 这里需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的，该功能会在后面具体描述。通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。 各种数据类型应用和实现方式下面我们先来逐一的分析下这7种数据类型的使用和内部实现方式:String:Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字.常用命令: set,get,decr,incr,mget 等。 应用场景： String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即 可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：获取字符串长度往字符串append内容设置和获取字符串的某一段内容设置及获取字符串的某一位（bit）批量设置一系列字符串的内容实现方式： String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。Hash常用命令： hget,hset,hgetall 等。应用场景： 在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。 这样不仅增大了开销，也不适用于一些可能并发操作的场合 （比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。 我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式： 第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。 第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图： 也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。实现方式：上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。List常用命令： lpush,rpush,lpop,rpop,lrange等。应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。Set常用命令：sadd,spop,smembers,sunion 等。应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。Sorted Set常用命令：zadd,zrange,zrem,zcard等使用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。Pub/SubPub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。Transactions谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。 Redis实际应用场景Redis在很多方面与其他数据库解决方案不同：它使用内存提供主存储支持，而仅使用硬盘做持久性的存储；它的数据模型非常独特，用的是单线程。另一个大区别在于，你可以在开发环境中使用Redis的功能，但却不需要转到Redis。 转向Redis当然也是可取的，许多开发者从一开始就把Redis作为首选数据库；但设想如果你的开发环境已经搭建好，应用已经在上面运行了，那么更换数据库框架显然不那么容易。另外在一些需要大容量数据集的应用，Redis也并不适合，因为它的数据集不会超过系统可用的内存。所以如果你有大数据应用，而且主要是读取访问模式，那么Redis并不是正确的选择。然而我喜欢Redis的一点就是你可以把它融入到你的系统中来，这就能够解决很多问题，比如那些你现有的数据库处理起来感到缓慢的任务。这些你就可以通过Redis来进行优化，或者为应用创建些新的功能。在本文中，我就想探讨一些怎样将Redis加入到现有的环境中，并利用它的原语命令等功能来解决 传统环境中碰到的一些常见问题。在这些例子中，Redis都不是作为首选数据库。 1、显示最新的项目列表 下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。SELECT * FROM foo WHERE … ORDER BY time DESC LIMIT 10 在Web应用中，“列出最新的回复”之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。 类似的问题就可以用Redis来解决。比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。 我们假设数据库中的每条评论都有一个唯一的递增的ID字段。 我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表：LPUSH latest.comments 我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论： LTRIM latest.comments 0 5000 每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成（使用伪代码）：FUNCTION get_latest_comments(start, num_items): id_list = redis.lrange(“latest.comments”,start,start+num_items - 1) IF id_list.length &lt; num_items id_list = SQL_DB(“SELECT … ORDER BY time LIMIT …”) END RETURN id_listEND 这里我们做的很简单。在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。 我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。 2、删除与过滤 我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。 有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。 3、排行榜相关 另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。 典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要： - 列出前100名高分选手 - 列出某用户当前的全球排名 这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。 模式是这样的，每次获得新得分时，我们用这样的代码： ZADD leaderboard &lt;score&gt; &lt;username&gt; 你可能用userID来取代username，这取决于你是怎么设计的。 得到前100名高分用户很简单：ZREVRANGE leaderboard 0 99。 用户的全球排名也相似，只需要：ZRANK leaderboard &lt;username&gt;。 4、按照用户投票和时间排序 排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序： score = points / time^alpha 因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。 模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。 每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。 有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。 5、处理过期项目 另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。 模式如下： - 每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。 - 另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目。 6、计数 Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。 我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。 好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。 例如这样操作： INCR user:&lt;id&gt; EXPIRE user:&lt;id&gt; 60 你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。 7、特定时间内的特定项目 另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。 每次我获得一次新的页面浏览时我只需要这样做： SADD page:day1:&lt;page_id&gt; &lt;user_id&gt; 当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。 想知道特定用户的数量吗？只需要使用SCARD page:day1:&lt;page_id&gt;。 需要测试某个特定用户是否访问了这个页面？SISMEMBER page:day1:&lt;page_id&gt;。 8、实时分析正在发生的情况，用于数据统计与防止垃圾邮件等 我们只做了几个例子，但如果你研究Redis的命令集，并且组合一下，就能获得大量的实时分析方法，有效而且非常省力。使用Redis原语命令，更容易实施垃圾邮件过滤系统或其他实时跟踪系统。 9、Pub/Sub Redis的Pub/Sub非常非常简单，运行稳定并且快速。支持模式匹配，能够实时订阅与取消频道。 10、队列 你应该已经注意到像list push和list pop这样的Redis命令能够很方便的执行队列操作了，但能做的可不止这些：比如Redis还有list pop的变体命令，能够在列表为空时阻塞队列。 现代的互联网应用大量地使用了消息队列（Messaging）。消息队列不仅被用于系统内部组件之间的通信，同时也被用于系统跟其它服务之间的交互。消息队列的使用可以增加系统的可扩展性、灵活性和用户体验。非基于消息队列的系统，其运行速度取决于系统中最慢的组件的速度（注：短板效应）。而基于消息队列可以将系统中各组件解除耦合，这样系统就不再受最慢组件的束缚，各组件可以异步运行从而得以更快的速度完成各自的工作。 此外，当服务器处在高并发操作的时候，比如频繁地写入日志文件。可以利用消息队列实现异步处理。从而实现高性能的并发操作。 11、缓存 Redis的缓存部分值得写一篇新文章，我这里只是简单的说一下。Redis能够替代memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据了。","categories":[{"name":"redis","slug":"redis","permalink":"http://hanyuanzhen.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://hanyuanzhen.com/tags/redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://hanyuanzhen.com/tags/NoSQL/"}]},{"title":"maven基本命令，配置和扩展","slug":"maven基本命令，配置和扩展","date":"2015-02-07T15:36:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/02/07/maven基本命令，配置和扩展/","link":"","permalink":"http://hanyuanzhen.com/2015/02/07/maven基本命令，配置和扩展/","excerpt":"主要介绍maven的用途、核心概念(Pom、Repositories、Artifact、BuildLifecycle、Goal)、用法（Archetype意义及创建各种项目）、maven常用参数和命令以及简单故障排除、maven扩展（eclipse、cobertura、findbugs、插件开发）、maven配置。 较长，可根据个人需要有选择性的查看，比如先看用法再回过头来看核心概念","text":"主要介绍maven的用途、核心概念(Pom、Repositories、Artifact、BuildLifecycle、Goal)、用法（Archetype意义及创建各种项目）、maven常用参数和命令以及简单故障排除、maven扩展（eclipse、cobertura、findbugs、插件开发）、maven配置。 较长，可根据个人需要有选择性的查看，比如先看用法再回过头来看核心概念 1、maven的用途maven是一个项目构建和管理的工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。maven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等。 2、maven的核心概念介绍2.1 Pompom是指project object Model。pom是一个xml，在maven2里为pom.xml。是maven工作的基础，在执行task或者goal时，maven会去项目根目录下读取pom.xml获得需要的配置信息pom文件中包含了项目的信息和maven build项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和goal、build选项等等pom是可以继承的，通常对于一个大型的项目或是多个module的情况，子模块的pom需要指定父模块的pompom文件中节点含义如下： 123456789101112project pom文件的顶级元素modelVersion 所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改groupId 是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId org.apache.maven.plugins就是为所有maven插件预留的artifactId 是项目artifact唯一的基地址名packaging artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的lifecycle。version artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本name 表示项目的展现名，在maven生成的文档中使用url表示项目的地址，在maven生成的文档中使用description 表示项目的描述，在maven生成的文档中使用dependencies 表示依赖，在子节点dependencies中添加具体依赖的groupId artifactId和versionbuild 表示build配置parent 表示父pom 其中groupId:artifactId:version唯一确定了一个artifact 2.2 Artifact这个有点不好解释，大致说就是一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(见Repository)中 2.3 RepositoriesRepositories是用来存储Artifact的。如果说我们的项目产生的Artifact是一个个小工具，那么Repositories就是一个仓库，里面有我们自己创建的工具，也可以储存别人造的工具，我们在项目中需要使用某种工具时，在pom中声明dependency，编译代码时就会根据dependency去下载工具（Artifact），供自己使用。对于自己的项目完成后可以通过mvn install命令将项目放到仓库（Repositories）中仓库分为本地仓库和远程仓库，远程仓库是指远程服务器上用于存储Artifact的仓库，本地仓库是指本机存储Artifact的仓库，对于windows机器本地仓库地址为系统用户的.m2/repository下面。对于需要的依赖，在pom中添加dependency即可，可以在maven的仓库中搜索：http://mvnrepository.com/ 2.4 Build Lifecycle是指一个项目build的过程。maven的Build Lifecycle分为三种，分别为default（处理项目的部署）、clean（处理项目的清理）、site（处理项目的文档生成）。他们都包含不同的lifecycle。Build Lifecycle是由phases构成的，下面重点介绍default Build Lifecycle几个重要的phase12345678validate 验证项目是否正确以及必须的信息是否可用compile 编译源代码test 测试编译后的代码，即执行单元测试代码package 打包编译后的代码，在target目录下生成package文件integration-test 处理package以便需要时可以部署到集成测试环境verify 检验package是否有效并且达到质量标准install 安装package到本地仓库，方便本地其它项目使用deploy 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成 以上的phase是有序的（注意实际两个相邻phase之间还有其他phase被省略，完整phase见lifecycle），下面一个phase的执行必须在上一个phase完成后若直接以某一个phase为goal，将先执行完它之前的phase，如mvn install将会先validate、compile、test、package、integration-test、verify最后再执行install phase 3、maven用法主要讲下Archetype以及几种常用项目的创建maven创建项目是根据Archetype（原型）创建的。下面先介绍下Archetype3.1 Archetype原型对于项目的作用就相当于模具对于工具的作用，我们想做一个锤子，将铁水倒入模具成型后，稍加修改就可以了。类似我们可以根据项目类型的需要使用不同的Archetype创建项目。通过Archetype我们可以快速标准的创建项目。利用Archetype创建完项目后都有标准的文件夹目录结构既然Archetype相当于模具，那么当然可以自己再造模具了啊，创建Archetype下面介绍利用maven自带的集中Archetype创建项目。创建项目的goal为mvn archetype:generate，并且指定archetypeArtifactId，其中archetypeArtifactId见maven自带的archetypeArtifactId 3.2 quick start工程创建一个简单的quick start项目，指定 -DarchetypeArtifactId为maven-archetype-quickstart，如下命令Xml代码 收藏代码mvn archetype:generate -DgroupId=com.trinea.maven.test -DartifactId=maven-quickstart -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false其中DgroupId指定groupId，DartifactId指定artifactId，DarchetypeArtifactId指定ArchetypeId，DinteractiveMode表示是否使用交互模式，交互模式会让用户填写版本信息之类的，非交互模式采用默认值这样我们便建好了一个简单的maven项目，目录结构如下： 现在我们可以利用2.4的build Lifecycle进行一些操作，先命令行到工程根目录下编译 mvn compile打包 mvn package，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件打包并安装到本地仓库mvn install，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。3.3 web工程创建一个简单的web项目，只需要修 -DarchetypeArtifactId为maven-archetype-webapp即可，如下命令 mvn archetype:generate -DgroupId=com.trinea.maven.web.test -DartifactId=maven-web -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false 其他：src\\main\\resources文件夹是用来存放资源文件的，maven工程默认没有resources文件夹，如果我们需要用到类似log4j.properties这样的配置文件，就需要在src\\main文件夹下新建resources文件夹，并将log4j.properties放入其中。test需要用到资源文件，类似放到src\\test下对于apache的log4j没有log4j.properties文件或是目录错误，会报如下异常 log4j:WARN No appenders could be found for logger (org.apache.commons.httpclient.HttpClient). log4j:WARN Please initialize the log4j system properly. 4、maven常用参数和命令主要介绍maven常用参数和命令以及简单故障排除4.1 mvn常用参数mvn -e 显示详细错误mvn -U 强制更新snapshot类型的插件或依赖库（否则maven一天只会更新一次snapshot依赖）mvn -o 运行offline模式，不联网更新依赖mvn -N仅在当前项目模块执行命令，关闭reactormvn -pl module_name在指定模块上执行命令mvn -ff 在递归执行命令过程中，一旦发生错误就直接退出mvn -Dxxx=yyy指定java全局属性mvn -Pxxx引用profile xxx 4.2 首先是2.4 Build Lifecycle中介绍的命令mvn test-compile 编译测试代码mvn test 运行程序中的单元测试mvn compile 编译项目mvn package 打包，此时target目录下会出现maven-quickstart-1.0-SNAPSHOT.jar文件，即为打包后文件mvn install 打包并安装到本地仓库，此时本机仓库会新增maven-quickstart-1.0-SNAPSHOT.jar文件。每个phase都可以作为goal，也可以联合，如之前介绍的mvn clean install 4.3 maven 日用三板斧mvn archetype:generate 创建maven项目mvn package 打包，上面已经介绍过了mvn package -Prelease打包，并生成部署用的包，比如deploy/*.tgzmvn install 打包并安装到本地库mvn eclipse:eclipse 生成eclipse项目文件mvn eclipse:clean 清除eclipse项目文件mvn site 生成项目相关信息的网站 4.4 maven插件常用参数mvn -Dwtpversion=2.0 指定maven版本mvn -Dmaven.test.skip=true 如果命令包含了test phase，则忽略单元测试mvn -DuserProp=filePath 指定用户自定义配置文件位置mvn -DdownloadSources=true -Declipse.addVersionToProjectName=true eclipse:eclipse 生成eclipse项目文件，尝试从仓库下载源代码，并且生成的项目包含模块版本（注意如果使用公用POM，上述的开关缺省已打开） 4.5 maven简单故障排除mvn -Dsurefire.useFile=false如果执行单元测试出错，用该命令可以在console输出失败的单元测试及相关信息set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m 调大jvm内存和持久代，maven/jvm out of memory errormvn -X maven log level设定为debug在运行mvndebug 运行jpda允许remote debugmvn –help 这个就不说了。。 5、maven扩展maven常用插件配置和使用 6、maven配置为了修改maven创建项目默认以来的jdk版本，看了下maven配置maven2.0默认使用jdk1.5导致反省、@override 等annotation不可用。可用两种方法修改jdk版本第一种：修改项目的pom.xml，影响单个项目，治标不治本 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; pom中增加build配置，指定java版本为1.6第二种：修改maven配置，影响maven建立的所有项目到maven安装目录的conf文件夹下，修改settings.xml文件，如下： &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.6&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.6&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.6&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 这样便能对所有默认的maven项目指定jdk为1.6","categories":[{"name":"maven教程","slug":"maven教程","permalink":"http://hanyuanzhen.com/categories/maven教程/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://hanyuanzhen.com/tags/maven/"},{"name":"项目构建","slug":"项目构建","permalink":"http://hanyuanzhen.com/tags/项目构建/"}]},{"title":"python标准库介绍","slug":"python标准库介绍","date":"2015-02-07T15:36:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/02/07/python标准库介绍/","link":"","permalink":"http://hanyuanzhen.com/2015/02/07/python标准库介绍/","excerpt":"python标准库包含操作系统接口，文件通配符，命令行参数。字符串正在表达式，日期和时间,数学函数，互联网访问接口，数据压缩以及质量和性能的控制等。接口丰富，提供开始效率。下面以例子的方式说明下各个库中的内容:","text":"python标准库包含操作系统接口，文件通配符，命令行参数。字符串正在表达式，日期和时间,数学函数，互联网访问接口，数据压缩以及质量和性能的控制等。接口丰富，提供开始效率。下面以例子的方式说明下各个库中的内容:python标准库包含操作系统接口，文件通配符，命令行参数。字符串正在表达式，日期和时间,数学函数，互联网访问接口，数据压缩以及质量和性能的控制等。接口丰富，提供开始效率。下面以例子的方式说明下各个库中的内容: 操作系统接口import osprint os.getcwd()print dir(os)print help(os) 文件通配符import globprint glob.glob(“*.py”) 命令行参数import sysprint sys.argv 字符串正则表达式import re‘tea for too’.replace(‘tea’, ‘water’)re.findall(r’\\b[a-z]*’,’which foot or hand fell fastest’) 数学计算import mathprint math.packageprint math.log(1023,2) 随机函数import randomprint random.choice([‘apple’,’orange’,’banana’])print random.random()print random.randrange(6)print random.sample(xrange(100),10) 日期和时间from datetime import dateprint date.today()now= date.today()print now.strftime(‘%m-%d-%y. %d %b %Y is a %A on the %d day of %B.’) 数据压缩import zlibs=b’witch which has which witches wrist watch’print len(s) b=zlib.compress(s)print len(b) c=zlib.decompress(b)print c 性能度量和质量控制1.doctest 模块和unittest 模块","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"},{"name":"标准库","slug":"标准库","permalink":"http://hanyuanzhen.com/tags/标准库/"}]},{"title":"python输入和输出","slug":"python输入和输出","date":"2015-02-04T16:04:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/02/05/python输入和输出/","link":"","permalink":"http://hanyuanzhen.com/2015/02/05/python输入和输出/","excerpt":"python的输入和输出可分为普控制台和文件等的读写，下面分析下python输入和输出的实现。","text":"python的输入和输出可分为普控制台和文件等的读写，下面分析下python输入和输出的实现。 一、格式化输入和输出若要对输出格式进行格式化，则控制输出的方式有以下几种:1.使用字符串切割和连接操作可以创建任何你想要的输出形式2.使用 str.format() 方法3.实例: 123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding:utf-8 -*-'''Created on 2015-2-4@author: Administrator'''#格式化输入和输出#1.str和repr函数 将数值转换为字符串s='hello,world!'print str(s)print repr(s) x=10*3.25y=200*200s= 'the value of x is'+repr(s)+','+'the value of y is '+str(y)print s#2.平方和立方表# s.rjust(),s.center()等把字符串输出一列，并以某格式对齐# for x in range(1,10):# print repr(x).rjust(2),repr(x*x).rjust(3),# print(repr(x*x*x).rjust(4))#s.format() 调用时使用关键字参数，可以通过参数名来引用值，也可以用 ‘**’ 标志将这个字典以关键字参数的方式传入。print 'the story of &#123;0&#125;,&#123;1&#125; is &#123;other&#125;'.format('bill','maryy', other='jhone')table=&#123;'lu':123,'wu':456,'li':4568&#125;print 'lu:&#123;lu:d&#125;;wu:&#123;wu:d&#125;'.format(**table) 二、文件的读写文件的操作主要包含打开，读写，定位，遍历，关闭等。具体的方法如下实例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding:utf-8 -*-'''Created on 2015-2-4@author: Administrator'''#文件的读写#f=open('d:/test.txt','r')f=open('d:/test.txt','wb+')#f.read()返回读取若干数量的数据并以字符串返回其内部，其中size是可变的整数值,若没有指定size或size的值为负数#则返回文件中所有的内容,若读取到文件的末尾则f.read()会返回一个空字符串#result=f.read()# result=f.read(10)# print result'''f.readline():从文件中读取单独一行，字符串结尾会自动加上一个换行符（ \\n ），只有当文件最后一行没有以换行符结尾时，这一操作才会被忽略.若f.readline返回一个空字符串，则表示达到了文件的末尾'''# line=f.readline()# print line'''f.readlines()：返回一个列表，其中包含了文件中所有的数据行.通常用于高效读取文件，避免将整个文件读入内存'''# lines=f.readlines()# print lines'''f.write()向文件中写入字符串内容f.tell() 返回一个整数，代表文件对象在文件中的指针位置f.seek(offset,from):指针在该操作中从指定的引用位置移动 offset个值，从from 开始移动'''# value=('answer:',12)# s=str(value)# f.write(s)# f.write(b\"145df454fad\")# print f.seek(5),f.seek(-2,2)'''with 处理文件对象是个好习惯。它的先进之处在于文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写'''# with open('d:test.txt','r') as f:# pass# print f.closed 三、pickle模块假如对文件内容直接用read()输出整数，则需要经过数据类型的转换才能正确获取。而python为了解决这样的麻烦，提供pickle实现。实现方式如下: 1234567 ''' pickle模块:可以将任何python对象封装为字符串，可以从字符串拆装成对象 若有一个对象x，以写模式打开文件对象，则pickle可以实现封装，若将f以读模式打开，则可拆装成对象'''pickle.dump(x,f)#封装x=pickle.load(f)#拆装","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"},{"name":"输入和输出","slug":"输入和输出","permalink":"http://hanyuanzhen.com/tags/输入和输出/"}]},{"title":"Ant之build.xml分析","slug":"Ant之build.xml分析","date":"2015-01-15T13:14:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2015/01/15/Ant之build.xml分析/","link":"","permalink":"http://hanyuanzhen.com/2015/01/15/Ant之build.xml分析/","excerpt":"可能有些读者并不连接什么是Ant以及入可使用它，但只要使用通过Linux系统得读者，应该知道make这个命令。当编译Linux内核及一些软件的源程序时，经常要用这个命令。Make命令其实就是一个项目管理工具，而Ant所实现功能与此类似。像make，gnumake和nmake这些编译工具都有一定的缺陷，但是Ant却克服了这些工具的缺陷。最初Ant开发者在开发跨平台的应用时，用样也是基于这些缺陷对Ant做了更好的设计。","text":"可能有些读者并不连接什么是Ant以及入可使用它，但只要使用通过Linux系统得读者，应该知道make这个命令。当编译Linux内核及一些软件的源程序时，经常要用这个命令。Make命令其实就是一个项目管理工具，而Ant所实现功能与此类似。像make，gnumake和nmake这些编译工具都有一定的缺陷，但是Ant却克服了这些工具的缺陷。最初Ant开发者在开发跨平台的应用时，用样也是基于这些缺陷对Ant做了更好的设计。 Ant的概念可能有些读者并不连接什么是Ant以及入可使用它，但只要使用通过Linux系统得读者，应该知道make这个命令。当编译Linux内核及一些软件的源程序时，经常要用这个命令。Make命令其实就是一个项目管理工具，而Ant所实现功能与此类似。像make，gnumake和nmake这些编译工具都有一定的缺陷，但是Ant却克服了这些工具的缺陷。最初Ant开发者在开发跨平台的应用时，用样也是基于这些缺陷对Ant做了更好的设计。 Ant 与 makefileMakefile有一些不足之处，比如很多人都会碰到的烦人的Tab问题。最初的Ant开发者多次强调”只是我在Tab前面加了一个空格，所以我的命令就不能执行”。有一些工具在一定程度上解决了这个问题，但还是有很多其他的问题。Ant则与一般基于命令的工具有所不同，它是Java类的扩展。Ant运行需要的XML格式的文件不是Shell命令文件。它是由一个Project组成的，而一个Project又可分成可多target，target再细分又分成很多task，每一个task都是通过一个实现特定接口的java类来完成的。 Ant的优点Ant是Apache软件基金会JAKARTA目录中的一个子项目，它有以下的优点。跨平台性。Ant是存Java语言编写的，所示具有很好的跨平台性。操作简单。Ant是由一个内置任务和可选任务组成的。Ant运行时需要一个XML文件(构建文件)。Ant通过调用target树，就可以执行各种task。每个task实现了特定接口对象。由于Ant构建文件时XML格式的文件，所以和容易维护和书写，而且结构很清晰。Ant可以集成到开发环境中。由于Ant的跨平台性和操作简单的特点，它很容易集成到一些开发环境中去。 Ant 开发Ant的构建文件当开始一个新的项目时，首先应该编写Ant构建文件。构建文件定义了构建过程，并被团队开发中每个人使用。Ant构建文件默认命名为build.xml，也可以取其他的名字。只不过在运行的时候把这个命名当作参数传给Ant。构建文件可以放在任何的位置。一般做法是放在项目顶层目录中，这样可以保持项目的简洁和清晰。下面是一个典型的项目层次结构。(1) src存放文件。(2) class存放编译后的文件。(3) lib存放第三方JAR包。(4) dist存放打包，发布以后的代码。Ant构建文件是XML文件。每个构建文件定义一个唯一的项目(Project元素)。每个项目下可以定义很多目标(target元素)，这些目标之间可以有依赖关系。当执行这类目标时，需要执行他们所依赖的目标。每个目标中可以定义多个任务，目标中还定义了所要执行的任务序列。Ant在构建目标时必须调用所定义的任务。任务定义了Ant实际执行的命令。Ant中的任务可以为3类。(1) 核心任务。核心任务是Ant自带的任务。(2) 可选任务。可选任务实来自第三方的任务，因此需要一个附加的JAR文件。(3) 用户自定义的任务。用户自定义的任务实用户自己开发的任务。 1.project标签每个构建文件对应一个项目。标签时构建文件的根标签。它可以有多个内在属性，就如代码中所示，其各个属性的含义分别如下。(1) default表示默认的运行目标，这个属性是必须的。(2) basedir表示项目的基准目录。(3) name表示项目名。(4) description表示项目的描述。每个构建文件都对应于一个项目，但是大型项目经常包含大量的子项目，每一个子项目都可以有自己的构建文件。 2.target标签一个项目标签下可以有一个或多个target标签。一个target标签可以依赖其他的target标签。例如，有一个target用于编译程序，另一个target用于声称可执行文件。在生成可执行文件之前必须先编译该文件，因策可执行文件的target依赖于编译程序的target。Target的所有属性如下。(1) name表示标明，这个属性是必须的。(2) depends表示依赖的目标。(3) if表示仅当属性设置时才执行。(4) unless表示当属性没有设置时才执行。(5) description表示项目的描述。Ant的depends属性指定了target的执行顺序。Ant会依照depends属性中target出现顺序依次执行每个target。在执行之前，首先需要执行它所依赖的target。程序中的名为run的target的depends属性compile，而名为compile的target的depends属性是prepare，所以这几个target执行的顺序是prepare-&gt;compile-&gt;run。一个target只能被执行一次，即使有多个target依赖于它。如果没有if或unless属性，target总会被执行。 3.mkdir标签该标签用于创建一个目录，它有一个属性dir用来指定所创建的目录名，其代码如下：&lt;mkdir dir=”＄{class.root}”/&gt;通过以上代码就创建了一个目录，这个目录已经被前面的property标签所指定。 4.jar标签该标签用来生成一个JAR文件，其属性如下。(1) destfile表示JAR文件名。(2) basedir表示被归档的文件名。(3) includes表示别归档的文件模式。(4) exchudes表示被排除的文件模式。 5．javac标签该标签用于编译一个或一组java文件，其属性如下:(1).srcdir表示源程序的目录。(2).destdir表示class文件的输出目录。(3).include表示被编译的文件的模式。(4).excludes表示被排除的文件的模式。(5).classpath表示所使用的类路径。(6).debug表示包含的调试信息。(7).optimize表示是否使用优化。(8).verbose 表示提供详细的输出信息。(9).fileonerror表示当碰到错误就自动停止。 6．java标签该标签用来执行编译生成的.class文件，其属性如下。(1).classname 表示将执行的类名。(2).jar表示包含该类的JAR文件名。(3).classpath所表示用到的类路径。(4).fork表示在一个新的虚拟机中运行该类。(5).failonerror表示当出现错误时自动停止。(6).output 表示输出文件。(7).append表示追加或者覆盖默认文件。 7.delete标签该标签用于删除一个文件或一组文件，去属性如下:(1).file表示要删除的文件。(2).dir表示要删除的目录。(3).includeEmptyDirs 表示指定是否要删除空目录，默认值是删除。(4).failonerror 表示指定当碰到错误是否停止，默认值是自动停止。(5).verbose表示指定是否列出所删除的文件，默认值为不列出。 8.copy标签该标签用于文件或文件集的拷贝，其属性如下。(1).file 表示源文件。(2).tofile 表示目标文件。(3).todir 表示目标目录。(4).overwrite 表示指定是否覆盖目标文件，默认值是不覆盖。(5).includeEmptyDirs 表示制定是否拷贝空目录，默认值为拷贝。(6).failonerror 表示指定如目标没有发现是否自动停止，默认值是停止。(7).verbose 表示制定是否显示详细信息，默认值不显示。 Ant的数据类型在构建文件中为了标识文件或文件组，经常需要使用数据类型。数据类型包含在org.apache.tool.ant.types包中。下面简单介绍构建文件中一些常用的数据类型。 1. argument 类型由Ant构建文件调用的程序，可以通过&lt;arg&gt;元素向其传递命令行参数，如apply,exec和java任务均可接受嵌套&lt;arg&gt;元素，可以为各自的过程调用指定参数。以下是&lt;arg&gt;的所有属性。(1).values 是一个命令参数。如果参数种有空格，但又想将它作为单独一个值，则使用此属性。(2).file表示一个参数的文件名。在构建文件中，此文件名相对于当前的工作目录。(3).line表示用空格分隔的多个参数列表。(4).path表示路径。 2.ervironment 类型由Ant构建文件调用的外部命令或程序，&lt;env&gt;元素制定了哪些环境变量要传递给正在执行的系统命令，&lt;env&gt;元素可以接受以下属性。(1).file表示环境变量值得文件名。此文件名要被转换位一个绝对路径。(2).path表示环境变量的路径。Ant会将它转换为一个本地约定。(3).value 表示环境变量的一个直接变量。(4).key 表示环境变量名。注意 file path 或 value只能取一个。 3.filelist类型Filelist 是一个支持命名的文件列表的数据类型，包含在一个filelist类型中的文件不一定是存在的文件。以下是其所有的属性。(1).dir是用于计算绝对文件名的目录。(2).files 是用逗号分隔的文件名列表。(3).refid 是对某处定义的一个&lt;filelist&gt;的引用。注意 dir 和 files 都是必要的，除非指定了refid(这种情况下，dir和files都不允许使用)。 4.fileset类型Fileset 数据类型定义了一组文件，并通常表示为&lt;fileset&gt;元素。不过，许多ant任务构建成了隐式的fileset,这说明他们支持所有的fileset属性和嵌套元素。以下为fileset 的属性列表。(1).dir表示fileset 的基目录。(2).casesensitive的值如果为false，那么匹配文件名时，fileset不是区分大小写的，其默认值为true。(3).defaultexcludes 用来确定是否使用默认的排除模式，默认为true。(4).excludes 是用逗号分隔的需要派出的文件模式列表。(5).excludesfile 表示每行包含一个排除模式的文件的文件名。(6).includes 是用逗号分隔的，需要包含的文件模式列表。(7).includesfile 表示每行包括一个包含模式的文件名。 5.patternset 类型Fileset 是对文件的分组，而patternset是对模式的分组，他们是紧密相关的概念。&lt;patternset&gt;支持4个属性：includes excludex includexfile 和 excludesfile,与fileset相同。Patternset 还允许以下嵌套元素：include,exclude,includefile 和 excludesfile。 6.filterset 类型Filterset定义了一组过滤器，这些过滤器将在文件移动或复制时完成文件的文本替换。主要属性如下：(1).begintoken 表示嵌套过滤器所搜索的记号，这是标识其开始的字符串。(2).endtoken表示嵌套过滤器所搜索的记号这是标识其结束的字符串。(3).id是过滤器的唯一标志符。(4).refid是对构建文件中某处定义一个过滤器的引用。 7.Path类型Path元素用来表示一个类路径，不过它还可以用于表示其他的路径。在用作揖个属性时，路经中的各项用分号或冒号隔开。在构建的时候，此分隔符将代替当前平台中所有的路径分隔符，其拥有的属性如下。(1).location 表示一个文件或目录。Ant在内部将此扩展为一个绝对路径。(2).refid 是对当前构建文件中某处定义的一个path的引用。(3).path表示一个文件或路径名列表。 8.mapper类型Mapper类型定义了一组输入文件和一组输出文件间的关系，其属性如下。(1).classname 表示实现mapper类的类名。当内置mapper不满足要求时，用于创建定制mapper。(2).classpath表示查找一个定制mapper时所用的类型路径。(3).classpathref是对某处定义的一个类路径的引用。(4).from属性的含义取决于所用的mapper。(5).to属性的含义取决于所用的mapper。(6).type属性的取值为identity，flatten glob merge regexp 其中之一，它定义了要是用的内置mapper的类型。 Ant 的运行安装好Ant并且配置好路径之后，在命令行中切换到构建文件的目录，输入Ant命令就可以运行Ant.若没有指定任何参数，Ant会在当前目录下查询build.xml文件。如果找到了就用该文件作为构建文件。如果使用了 –find 选项，Ant 就会在上级目录中找构建文件，直至到达文件系统得跟目录。如果构建文件的名字不是build.xml ，则Ant运行的时候就可以使用 –buildfile file,这里file 指定了要使用的构建文件的名称，示例如下：Ant如下说明了表示当前目录的构建文件为build.xml 运行 ant 执行默认的目标。Ant –buildfile test.xml使用当前目录下的test.xml 文件运行Ant ,执行默认的目标","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://hanyuanzhen.com/categories/项目管理/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://hanyuanzhen.com/tags/版本控制/"},{"name":"Ant","slug":"Ant","permalink":"http://hanyuanzhen.com/tags/Ant/"}]},{"title":"python网络编程之UDP实现","slug":"python网络编程之UDP实现","date":"2014-12-26T16:01:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/12/27/python网络编程之UDP实现/","link":"","permalink":"http://hanyuanzhen.com/2014/12/27/python网络编程之UDP实现/","excerpt":"python udp是无连接，没有TCP的三次握手，错误重传机制，发的只管发，收的只管收，效率比TCP高，运用于对数据帧不高的地方，如视频，音频的传输。","text":"python udp是无连接，没有TCP的三次握手，错误重传机制，发的只管发，收的只管收，效率比TCP高，运用于对数据帧不高的地方，如视频，音频的传输。 一、简介:python udp是无连接，没有TCP的三次握手，错误重传机制，发的只管发，收的只管收，效率比TCP高，运用于对数据帧不高的地方，如视频，音频的传输。 二、实现过程: 服务器端过程如下:1.建立UDP的SOCKET2.绑定一个接口，让客户端连接3.接受数据 客户端过程如下:1.创建一个socket2.收发数据报 python网络编程之UDP实现 1.服务器端：12345678910111213141516import socketfrom time import ctimedef udpServer(): buffer=2048 address=(\"127.0.0.1\",8080) udpsock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) udpsock.bind(address) while True: print \"wait for message...\" data,addr=udpsock.recvfrom(buffer) udpsock.sendto('[%s]%s' %(ctime(),data),addr) print '...received from and retuned to:',addr udpsock.close()if __name__==\"__main__\": udpServer() 2.客户端: 123456789101112131415import socketdef udpClient(): address=('localhost',8080) udpClientSocket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #创建socket while True: data=raw_input('&gt;') if not data: break udpClientSocket.sendto(data,address) #发送数据 data,addr=udpClientSocket.recvfrom(2048) print data udpClientSocket.close() if __name__==\"__main__\": udpClient()","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"},{"name":"udp实现","slug":"udp实现","permalink":"http://hanyuanzhen.com/tags/udp实现/"}]},{"title":"python网络编程之TCP实现","slug":"python网络编程之TCP实现","date":"2014-12-26T15:51:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/12/26/python网络编程之TCP实现/","link":"","permalink":"http://hanyuanzhen.com/2014/12/26/python网络编程之TCP实现/","excerpt":"python的tcp是也是面向连接，服务器的过程和客户端的过程和其他语言类似，下面分析TCP实现。","text":"python的tcp是也是面向连接，服务器的过程和客户端的过程和其他语言类似，下面分析TCP实现。 一、原理 tcp是面向连接，服务器的过程如下: 1.创建一个socket(socket的类型，socket的协议) 2.绑定(bind)一个端口，使客户端连接、 3.设置监听队列(listen)的大小 4.进入无限循环，使用accpet()接收客户端请求 5.通过send/recv()对socket进行读写操作 客户端的过程如下: 1.创建一个socket(socket的类型，socket的协议) 2.用connect连接远程端口、 3.通过send/recv()对socket进行读写操作 二、代码实现如下: 1.服务器端: 1234567891011121314151617181920212223242526272829303132333435import socketfrom time import ctimedef tcpServer(): address=(\"127.0.0.1\",8080) #初始化socket tcpsock=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #绑定端口地址 tcpsock.bind(address) #设置监听 tcpsock.listen(5) while True: print \"wait a client connect...\" #接受客户端连接 con,addr=tcpsock.accept() while True: try: con.settimeout(20) #接收数据 buf =con.recv(1024) # con.send('[%s]%s' %(ctime(),buf)) if buf==\"1\": con.send(\"1\") elif buf==\"2\": con.send(\"2\") elif buf==\"3\": con.send(\"3\") break else: con.send(\"unknow command\") except socket.timeout: print \"time out\" con.close() print \"a clinet exit...\"if __name__==\"__main__\": tcpServer() 2.客户端 1234567891011121314151617def tcpClient(): address=(\"127.0.0.1\",8080) #初始化socket tcpClientsock =socket.socket(socket.AF_INET,socket.SOCK_STREAM) #建立连接 tcpClientsock.connect(address) while True: #输入口令 data=raw_input(\"input the command:\") #发送请求 tcpClientsock.send(data) print tcpClientsock.recv(1024) if data==3: break tcpClientsock.close() if __name__==\"__main__\": tcpClient()","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"},{"name":"TCP实现","slug":"TCP实现","permalink":"http://hanyuanzhen.com/tags/TCP实现/"}]},{"title":"python的内置数据类型","slug":"python的内置数据类型","date":"2014-11-13T15:23:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/11/13/python的内置数据类型/","link":"","permalink":"http://hanyuanzhen.com/2014/11/13/python的内置数据类型/","excerpt":"python的内置数据类型和其他语言类似也有相同点，也有不同点，如整型(int),布尔类型 ，列表(list) ，字符串型(str)，元组(tuple)和字典(dict)，下面分析各数据类型的使用。","text":"python的内置数据类型和其他语言类似也有相同点，也有不同点，如整型(int),布尔类型 ，列表(list) ，字符串型(str)，元组(tuple)和字典(dict)，下面分析各数据类型的使用。 一、基本的数据类型整型(int) 如123布尔类型 布尔类型用于逻辑判断，有True和False两种结果字符串型(str) 用””或’’表示。如”helloworld” ‘student’列表(list) 用[]表示，如[‘A’,’B’,’C’]元组(tuple) 用()表示 如(1，3，4)字典(dict) 用{键值对} 表示 如:{name:’zhangsan’,age:20}以上数据类型:可变的数据类型:列表(list),字典(dict)不可变的数据类型:整型(int),字符串(str),元组(tuple) 二、常用类型的一些操作(1)字符串类型字符串类型是由连续的单个字符组成，可以表示文本.是不可变类型，若需要修改，则只能重新创建一个字符串1.字符串的创建 s1=’helloworld’或”helloworld” str()方法 a=123 print str(a) 则输出”123”2.字符串的查找 主要有正向和反向查找，用下标或索引方式 正向查找(用下标0开始) a=’123’ 则a[0]为’1’ 反向查找(从下标-1开始) a=’12bc’ 则a[-1]为’c’ 还有a[0:]表示从下标0开始到结尾的所有字符。其他类似 3.字符串的修改和删除 字符串和数字一样都是不可变数据类型，不能进行修改操作。要想修改或是删除原有字符串数据，重新创建一个字符串。 4.字符串和操作符A.序列操作符切片（[]和[:]）B.成员操作符C.连接操作符e.普通串转换为unicode串 只适用于字符串的操作符1.格式化操作符(%)2.字符串模板3.原始操作符5.内建函数cmp()len()zip()enumerate字符串类型函数raw_inputstr()and unicdoe()chr() and ord() (2).序列由不同类型共同组成的一个整体序列的每一个元素可以通过指定一个偏移量的方式访问1.标准类型操作符2.序列类型操作符a.成员关系 (in or not in)b.连接操作符(+)c.重复操作符(*)d.切片操作符([],[:],[::])e.用步长索引进行扩展的切片操作f.切片索引更多内容3.内建函数a.内型转化 如:list(iter),str[obj],tuple(iter) b.浅拷贝和深拷贝 (3).列表列表是一个容器，能保存任何类型元素1.创建列表类型的数据和赋值用[]括起来2.访问列表中的值aList[0] 3.列表的更新可以用append()追加元素；也可以用索引更新一个或几个元素 4.列表元素的删除del：删除确切要删除的元素 如:l=[‘a’,’b’,1] del l[2] 则会将1删掉remove():部分移除元素 5.操作符标准操作符切片操作符[：]成员关系（in not in）连接操作符:列表类型的连接操作只能是相同类型之间进行重复操作符(*) (4).元组 元组是一个有序的集合，支持一般序列的操作；如（1,2）+（2,3） 得到（1,2,2,3）1.元组的创建用()包括，()中的元素用逗号进行分割如:(‘A’,’B’,’C’) 也可以不用()包起来，如 &gt;&gt;&gt; 4，5,6 若只有一个元素,则该元素后需要加逗号,如’A’tuple()函数创建，括号内的元素可以是列表，字符串等如tuple([1,2,3])；tuple(‘hello’) 2.访问元组 可用下标和切片的方式；如y=(‘A’,’B’,’C’) 则y[0:1]为(‘A’,’B’) 3.更新元组 元组是不可变类型，不在再本身的基础上修改，可以转换为列表进行修改 如 a=(1,2,3) b=list(a) b=[1,2,3] b[0]=2 则a=tuple(b) 得到（2，2,3） 若元组中包含了可变的数据类型，则可修改 4.移除元组 5.元组的操作符和内建函数 a.创建，重复和连接操作 b.成员关系和切片操作 c.内建函数（str(),min(),list()） d.操作符","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"},{"name":"内置数据类型","slug":"内置数据类型","permalink":"http://hanyuanzhen.com/tags/内置数据类型/"}]},{"title":"python+mysqldb数据库环境搭建和入门","slug":"python+mysqldb数据库环境搭建和入门","date":"2014-10-29T16:55:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/10/30/python+mysqldb数据库环境搭建和入门/","link":"","permalink":"http://hanyuanzhen.com/2014/10/30/python+mysqldb数据库环境搭建和入门/","excerpt":"python+mysqldb数据库环境搭建需要安装相关插件和配置，下面具体分析如何搭建和配置。","text":"python+mysqldb数据库环境搭建需要安装相关插件和配置，下面具体分析如何搭建和配置。 一、工具安装和配置我选择的是python2.7版本(32位)，eclipse，PyDev 2.7.5 和mysqldb(32位)各文件的下载路径为:python2.7地址:http://download.csdn.net/detail/xhwwc110/8098095或者https://www.python.org/downloads/release/python-278/PyDev 2.7.5地址:http://sourceforge.net/projects/pydev/files/pydev/eclipse地址:http://www.eclipse.org/downloads/mysqldb(32位)地址：http://download.csdn.net/detail/xhwwc110/8098105或http://www.codegood.com/archives/129 (1).python和eclipe的安装很简单，直接运行安装文件即可 ( 2).pydev集成在eclipse中，可以有在线安装和离线安装。 1.在线安装方式为:打开Eclipse，找到Help菜单栏，进入Install New Software选项。但因版本冲突问题没有安装成功。 参考如下: 2.选择离线安装方法，离线安装方式为: A.把下载好的pydev压缩文件解压后,得到features和plugins两个文件夹，然后将两个文件夹中的文件分别拷贝到Eclipse安装目录下的features和plugins目录中。 B.打开eclipse，点击windows-preferences选择pydev,选择Interpreter-Python，点击new，添加python C.选择好libraries下的配置依赖包，点击OK，安装完成 (3).python配置MySQLdb 1.首先需要安装好MySQLdb,具体的安装可参考如下: 2.在python shell 用import MySQLdb进行测试，没有异常,则提示安装成功 若出现如下信息: 12345import MySQLdbTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"C:\\Python25\\Lib\\site-packages\\MySQLdb\\__init__.py\", line 19, in &lt;module&gt; import _mysql ImportError: DLL load failed: 找不到指定的程序。则为安装失败。解决方法:A.下载libmmd.dll,libmySQL.dll和libguide40.dll文件并复制到python安装目录的Lib\\site- packages下 下载地址为:B.检查下python和mysqldb的版本属性。若不一致(32位对应64位)会出现”DLL load failed: 找不到指定的程序” (4).在eclipse中配置MySQLdb 1.选择pydev-Interpreter-Python,在Forced Builtins下面手工添加 MySQLdb 字段。Apply之后，可以看到 Libraries 下面添加了 MySQLdb的目录。如果没有，则手工在Libraries 下面添加MySQLdb的目录，再次强制编译即可。 二、python数据库编程例子 (1).以下是一个连接mysql创建数据库和创建一个表的简单例子.可以测试下MySQLdb是否能正常使用。 1234567891011121314151617 #!usr/bin/env python# -*- coding:utf-8 -*-import MySQLdbtry: conn=MySQLdb.connect(host='localhost',user='root',passwd='root',port=3306) cur=conn.cursor() cur.execute('create database if not exists python') conn.select_db('python') cur.execute('create table student(id int,info varchar(20))') conn.commit() cur.close() conn.close() except MySQLdb.Error,e: print \"Mysql Error %d: %s\" % (e.args[0], e.args[1]) 执行完成后，检查mysql中是否存在该数据库和表。","categories":[{"name":"python开发","slug":"python开发","permalink":"http://hanyuanzhen.com/categories/python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"http://hanyuanzhen.com/tags/python/"}]},{"title":"Spring Mvc入门分析","slug":"Spring Mvc入门","date":"2014-05-16T15:54:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/05/16/Spring Mvc入门/","link":"","permalink":"http://hanyuanzhen.com/2014/05/16/Spring Mvc入门/","excerpt":"Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。","text":"Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。 一、什么是spring mvc Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。Spring Web MVC也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器其实拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(View Resolver)进行视图管理；页面控制器/动作/处理器为Controller接口（仅包含ModelAndView handleRequest(request, response) 方法）的实现（也可以是任何的POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持。 二、spring mvc的工作流程（1）、下图为spring mvc的工作流程图： （2）、具体执行步骤如下：1、 首先用户发送请求————&gt;前端控制器，前端控制器根据请求信息（如URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图2-1中的1、2步骤；2、 页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在Spring Web MVC中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView（模型数据和逻辑视图名）；图2-1中的3、4、5步骤；3、 前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图2-1中的步骤6、7；4、 前端控制器再次收回控制权，将响应返回给用户，图2-1中的步骤8；至此整个结束。（3）、涉及到是API Dispatcher Servlet分发器 Handler Mapping 处理器映射 Controller 控制器 ModelAndView ViewResolver 视图解析器 三、体验spring mvc（1）、开发步骤：1.新建一个webProject 2.导入jar 依赖包如下： spring-aop-3.2.2.jar 面向切片编程； spring-aspects-3.2.2.jar 提供对AspectJ的支持，以便可以方便的将面向方面的功能集成进IDE中； spring-beans-3.2.2.jar 核心。访问配置文件、创建和管理bean 以及进行IoC/DI操作相关的所有类； spring-context-3.2.2.jar为Spring 核心提供了大量扩展； spring-context-support-3.2.2.jar spring-core-3.2.2.jar Spring 框架基本的核心工具类。外部依赖Commons Logging ； spring-expression-3.2.2.jar 配置对象的注入，它便是SpEL ; spring-web-3.2.2.jar Web 应用开发时，用到Spring 框架时所需的核心类； spring-webmvc-3.2.2.jar Spring MVC 框架相关的所有类。包括框架的Servlets，WebMVC框架，控制器和视图支持,注意spring3.0的包名是 org.spingframework.web.servlet-3.1.0RELEASE.jar； commons.logging-1.1.1.jar 日志； aopalliance-1.0.0.jar AOP联盟的API包，里面包含了针对面向切面的接口。 3.在web.xml配置 DispatcherServlet和映射 1234567891011121314&lt;!-- 配置分发器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 配置映射的类 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4.创建WebController 123456789101112131415161718192021package cn.com.action;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.AbstractController;public class WebController extends AbstractController &#123; private final Log logger=LogFactory.getLog(getClass());// private Properties properties =SysConfig.getProperties(\"\"); @Override public ModelAndView handleRequestInternal(HttpServletRequest resquest, HttpServletResponse response) throws Exception &#123; logger.info(\"servlet request......start\"); return new ModelAndView(\"success\"); &#125;&#125; 5.在src根目录下创建并配置spring-mvc.xml文件 1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt; &lt;!-- 控制器 --&gt;&lt;bean id=\"/webController.do\" class=\"cn.com.action.WebController\"&gt;&lt;/bean&gt;&lt;!-- 视图资源解析器 --&gt;&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt;&lt;!-- 前缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;!-- 后缀 --&gt;&lt;/bean&gt;&lt;/beans&gt; 6.创建jsp页面 /WEB-INF/pages/index.jsp7.进行部署和发布以上就是spring mvc最基本和最简单的开发流程，通过请求：http://localhost:8080/springmvc/webController.do，如果页面输出正常,就表示成功了！","categories":[{"name":"web开发","slug":"web开发","permalink":"http://hanyuanzhen.com/categories/web开发/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://hanyuanzhen.com/tags/web开发/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://hanyuanzhen.com/tags/SpringMvc/"}]},{"title":"web.xml配置的元素加载顺序和详解","slug":"web.xml配置的元素加载顺序和详解","date":"2014-04-12T15:22:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/04/12/web.xml配置的元素加载顺序和详解/","link":"","permalink":"http://hanyuanzhen.com/2014/04/12/web.xml配置的元素加载顺序和详解/","excerpt":"一般的工程都会有用到web.xml文件,但不是必须的，web.xml的主要作用是配置，主要配置filter ,listener,servlet,session等，下面分析下web.xml中给元素的加载顺序。","text":"一般的工程都会有用到web.xml文件,但不是必须的，web.xml的主要作用是配置，主要配置filter ,listener,servlet,session等，下面分析下web.xml中给元素的加载顺序。 一、web.xml加载过程web工程中加载跟配置的参数与节点的顺序没有关系,主要加载顺序为ServletContext -&gt; context-param -&gt; listener -&gt; filter -&gt; servlet。并且这些元素可以配置在文件中的任意位置。（1）、加载过程如下:启动web项目时，会现在加载web.xml文件,读取listener和context-param节点，然后会加载servletcontext(servlet上下文)，这个web项目的所有部分都将共享这个上下文。容器将转换为键值对，并交给servletContext。容器创建中的类实例，创建监听器。 二、web.xml各节点详细分析:schema,按照sun公司的指定来定义，都必须标明这个 web.xml使用的是哪个模式文件。其它的元素都放在web-app的节点之中。 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.4\"xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; （2）、以下为引用别人对web.xml中其他元素的总结，主要总结如下:display-name:定义了WEB应用的名字description: 声明WEB应用的描述信息 context-param:元素声明应用范围内的初始化参数。filter:过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。filter-mapping:一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联。listener:servlet API的版本2.3增加了对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。 Listener元素指出事件监听程序类。servlet:在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。servlet-mapping:服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。 但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素。 session-config:如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值。 mime-mapping:如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证。welcome-file-list:指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件。error-page:在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。taglib:对标记库描述符文件（Tag Libraryu Descriptor file）指定别名。此功能使你能够更改TLD文件的位置， 而不用编辑使用这些文件的JSP页面。resource-env-ref:声明与资源相关的一个管理对象。resource-ref:声明一个资源工厂使用的外部资源。security-constraint:制定应该保护的URL。它与login-config元素联合使用login-config:指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用。security-role:给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素 的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。env-entry:声明Web应用的环境项。 （3）、相应元素配置 1、Web应用图标：指出IDE和GUI工具用来表示Web应用的大图标和小图标 1234&lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt; &lt;/icon&gt; 2、Web 应用名称：提供GUI工具可能会用来标记这个特定的Web应用的一个名称 1&lt;display-name&gt;Tomcat Example&lt;/display-name&gt; 3、Web 应用描述： 给出于此相关的说明性文本 1&lt;disciption&gt;Tomcat Example servlets and JSP pages.&lt;/disciption&gt; 4、上下文参数：声明应用范围内的初始化参数。 12345&lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; 在servlet里面可以通过getServletContext().getInitParameter(“context/param”)得到 5、过滤器配置：将一个名字与一个实现javaxs.servlet.Filter接口的类相关联。 123456789101112&lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;GB2312&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 6、监听器配置 123&lt;listener&gt; &lt;listerner-class&gt;listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; 7、Servlet配置 基本配置 12345678&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 高级配置 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;SnoopServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;foo&lt;/param-name&gt; &lt;param-value&gt;bar&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;Security role for anonymous access&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 元素说明 1234567891011&lt;servlet&gt;&lt;/servlet&gt; 用来声明一个servlet的数据，主要有以下子元素： &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定servlet的名称 &lt;servlet-class&gt;&lt;/servlet-class&gt; 指定servlet的类名称 &lt;jsp-file&gt;&lt;/jsp-file&gt; 指定web站台中的某个JSP网页的完整路径 &lt;init-param&gt;&lt;/init-param&gt; 用来定义参数，可有多个init-param。在servlet类中通过getInitParamenter(String name)方法访问初始化参数 &lt;load-on-startup&gt;&lt;/load-on-startup&gt;指定当Web应用启动时，装载Servlet的次序。 当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet. 当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它 &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 用来定义servlet所对应的URL，包含两个子元素 &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定servlet的名称 &lt;url-pattern&gt;&lt;/url-pattern&gt; 指定servlet所对应的URL 8、会话超时配置（单位为分钟） 123&lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; 9、MIME类型配置 1234&lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; 10、指定欢迎文件页配置 12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 11、配置错误页面 通过错误码来配置error-page 1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; 上面配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp。通过异常的类型配置error-page 1234&lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 上面配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp12、TLD配置 1234567891011&lt;taglib&gt; &lt;taglib-uri&gt;http://jakarta.apache.org/tomcat/debug-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/jsp/debug-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; 如果MyEclipse一直在报错,应该把&lt;taglib&gt; 放到 &lt;jsp-config&gt;中 &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://jakarta.apache.org/tomcat/debug-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/pager-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; 13、资源管理对象配置 123&lt;resource-env-ref&gt; &lt;resource-env-ref-name&gt;jms/StockQueue&lt;/resource-env-ref-name&gt; &lt;/resource-env-ref&gt; 14、资源工厂配置 12345&lt;resource-ref&gt; &lt;res-ref-name&gt;mail/Session&lt;/res-ref-name&gt; &lt;res-type&gt;javax.mail.Session&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 配置数据库连接池就可在此配置： 123456&lt;resource-ref&gt; &lt;description&gt;JNDI JDBC DataSource of shop&lt;/description&gt; &lt;res-ref-name&gt;jdbc/sample_db&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 15、安全限制配置 123456789101112131415&lt;security-constraint&gt; &lt;display-name&gt;Example Security Constraint&lt;/display-name&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Protected Area&lt;/web-resource-name&gt; &lt;url-pattern&gt;/jsp/security/protected/*&lt;/url-pattern&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;role-name&gt;role1&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; 16、登陆验证配置 12345678&lt;login-config&gt; &lt;auth-method&gt;FORM&lt;/auth-method&gt; &lt;realm-name&gt;Example-Based Authentiation Area&lt;/realm-name&gt; &lt;form-login-config&gt; &lt;form-login-page&gt;/jsp/security/protected/login.jsp&lt;/form-login-page&gt; &lt;form-error-page&gt;/jsp/security/protected/error.jsp&lt;/form-error-page&gt; &lt;/form-login-config&gt; &lt;/login-config&gt; 17、安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中,分别地声明角色可使高级IDE处理安全信息更为容易。 123&lt;security-role&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/security-role&gt; 18、Web环境参数：env-entry元素声明Web应用的环境项 12345&lt;env-entry&gt; &lt;env-entry-name&gt;minExemptions&lt;/env-entry-name&gt; &lt;env-entry-value&gt;1&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt; &lt;/env-entry&gt; 19、EJB 声明 1234567&lt;ejb-ref&gt; &lt;description&gt;Example EJB reference&lt;/decription&gt; &lt;ejb-ref-name&gt;ejb/Account&lt;/ejb-ref-name&gt; &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt; &lt;home&gt;com.mycompany.mypackage.AccountHome&lt;/home&gt; &lt;remote&gt;com.mycompany.mypackage.Account&lt;/remote&gt; &lt;/ejb-ref&gt; 20、本地EJB声明 1234567&lt;ejb-local-ref&gt; &lt;description&gt;Example Loacal EJB reference&lt;/decription&gt; &lt;ejb-ref-name&gt;ejb/ProcessOrder&lt;/ejb-ref-name&gt; &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt; &lt;local-home&gt;com.mycompany.mypackage.ProcessOrderHome&lt;/local-home&gt; &lt;local&gt;com.mycompany.mypackage.ProcessOrder&lt;/local&gt; &lt;/ejb-local-ref&gt; 21、配置DWR 12345678&lt;servlet&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;servlet-class&gt;uk.ltd.getahead.dwr.DWRServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 22、配置Struts 12345678910111213141516171819202122232425262728293031&lt;display-name&gt;Struts Blank Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt; org.apache.struts.action.ActionServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;detail&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;application&lt;/param-name&gt; &lt;param-value&gt;ApplicationResources&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 23、配置Spring（基本上都是在Struts中配置的） 1234567891011121314151617181920&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!--加载多个spring配置文件 --&gt; /WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 定义SPRING监听器，加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; 三、映射规则当一个请求发送到servlet时，容器会根据当前的url减去context上下文后剩余的部分去匹配，比如请求地址为http://localhost/test/LoginServlet，我的应用上下文是test，容器会将http://localhost/test去掉，剩下的/LoginServlet部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了。匹配规则1.精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 / ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了。2.最长路径匹配。例子：servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。3.扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet。例子：servletA的url-pattern：.action以”/’开头和以”/”结尾的是用来做路径映射的。以前缀”.”开头的是用来做扩展映射的。所以，为什么定义”/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。","categories":[{"name":"web开发","slug":"web开发","permalink":"http://hanyuanzhen.com/categories/web开发/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://hanyuanzhen.com/tags/web开发/"},{"name":"xml","slug":"xml","permalink":"http://hanyuanzhen.com/tags/xml/"}]},{"title":"Hibernate概述和增删改查入门","slug":"Hibernate概述和增删改查入门","date":"2014-03-30T17:00:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/03/31/Hibernate概述和增删改查入门/","link":"","permalink":"http://hanyuanzhen.com/2014/03/31/Hibernate概述和增删改查入门/","excerpt":"Hibernate是一种轻量级的javaEE持久层解决方案，是一种关系型数据库的ORM映射框架，是完全的对数据库SQL进行封装，使用java对象操作，生成相应的SQL，完成对底层数据的操作.","text":"Hibernate是一种轻量级的javaEE持久层解决方案，是一种关系型数据库的ORM映射框架，是完全的对数据库SQL进行封装，使用java对象操作，生成相应的SQL，完成对底层数据的操作. 一、hiberante框架概述(1).Hibernate是一种轻量级的javaEE持久层解决方案，是一种关系型数据库的ORM映射框架，是完全的对数据库SQL进行封装，使用java对象操作，生成相应的SQL，完成对底层数据的操作.(2).使用Hibernate的好处1.简化编码操作2.应用其内部的优化机制(一级，二级缓存,抓取策略等),来提高数据的操作性能3.可使用java对象操作数据库,能对底层数据操作进行完全的封装 二、Hibernate入门开发1.搭建Hibernate环境，导入相应的jar包可从http://sourceforge.net/projects/hibernate/files 下载开发包所需jar包如下:一些包的描述: hibernate3.jar—— 核心jar包 hibernate-jpa-2.0-api-1.0.1.Final.jar——hibernate注解、web项目中依赖 包 slf4j, slf4j-log4j12-1.7.2.jar——hibernate框架使用默认日志技术,需要与log4j整合实现 2.建立相依的实体类,以及相应的hbm(映射文件)A.创建实体类Person.java,包含的属性为id,name,city.其对应的映射文件为（Person.hbm.xml）B.主要配置如下 123456789101112131415161718192021&lt;hibernate-mapping&gt; &lt;!-- name 完整类名,table 表名,catalog 数据库名 --&gt; &lt;class name=\"com.w2cboy.model.Person\" table=\"person\" catalog=\"ceshidb\"&gt; &lt;!-- 主键生成策略配置 --&gt; &lt;!-- name Perosn类中生成注解 属性名 column 表中列名 type 数据类型 （Java数据类型、Hibernate数据类型 、 SQL数据类型 ） --&gt; &lt;id name=\"id\" column=\"id\" type=\"int\"&gt; &lt;!-- 使用本地策略 --&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 配置其它属性 --&gt; &lt;property name=\"name\" column=\"name\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;!-- SQL类型 必须编写 column 元素--&gt; &lt;property name=\"city\" column=\"city\" type=\"string\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.创建并配置hibernate核心配置文件在src目录下创建hibernate.cfg.xml文件，主要配置JDBC连接信息，其配置信息如下： 1234567891011121314151617181920212223 &lt;hibernate-configuration&gt;&lt;!-- Hibernate中数据库连接 通过 session对象进行管理 --&gt;&lt;session-factory&gt; &lt;!-- 连接数据库，必须配置 JDBC 四个基本连接参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///ceshidb&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123&lt;/property&gt; &lt;!-- 配置数据库方言 不同 数据库 SQL 不完全一样--&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 在控制台打印生成的SQL语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 对控制台输出SQL语句进行格式化，为了方便阅读 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 可以自动根据类生成DDL 建表语言，完成自动建表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 在核心配置文件中 加载 hbm 映射文件 --&gt; &lt;mapping resource=\"com/w2cboy/model/Person.hbm.xml\"/&gt;&lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 4.编写测试用例(实现CRUD操作)1.session工具类: //实例化配置对象，加载配置文件 hibernate.cfg.xml Configuration configuration = new Configuration().configure(); //创建会话连接工厂 SessionFactory sessionFactory = configuration.buildSessionFactory(); //创建会话 Session session = sessionFactory.openSession(); //开启事务 Transaction transaction = session.beginTransaction(); //提交事务，释放资源 transaction.commit(); session.close(); sessionFactory.close(); 2.CRUD操作 1) 根据id 查询 通过 Session类 提供 get/load 方法 ; 12int id = 1; Person person= (Person ) session.get(person .class, id); 2）修改update方法， 默认根据 id 修改 表其它所有字段 通过 Session类 提供 update; 1234person person = new Person (); person .setName(\"张三\"); person .setCity(\"上海\"); session.update(person); 3）删除操作， 根据id 删除， 通过Session类提供 delete ; 123person person = new Person ();person.setId(1);session.delete(perosn); 4） 查询所有数据 通过Query 接口完成， Query接口 接收HQL 查询语句 Query提供子接口 SQLQuery ， 接收SQL 查询语句 Hibernate框架内部提供，格式和SQL语句非常类似，区别SQL 面向数据表查询语句， HQL面向Java类和对象查询语句 12345678HQL查询 String hql = \"from Person\";//面向类和对象 Query query = session.createQuery(hql); //获得Query对象 List&lt;Person&gt; persons= query.list();//执行查询SQL 查询 String sql = \"select * from person\"; SQLQuery sqlQuery = session.createSQLQuery(sql); 所以总的来说，hiberante的配置文件，和映射文件是实现的关键。","categories":[{"name":"web开发","slug":"web开发","permalink":"http://hanyuanzhen.com/categories/web开发/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://hanyuanzhen.com/tags/web开发/"},{"name":"hiberante","slug":"hiberante","permalink":"http://hanyuanzhen.com/tags/hiberante/"}]},{"title":"核心java系列——循环效率的比较","slug":"Iterator,for,forEach的遍历和效率","date":"2014-03-24T11:47:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/03/24/Iterator,for,forEach的遍历和效率/","link":"","permalink":"http://hanyuanzhen.com/2014/03/24/Iterator,for,forEach的遍历和效率/","excerpt":"java中对集合或数组等类型的数据遍历方式有很多，每种方式的时间复杂度和空间复杂度都各有差异，下面介绍下Iterator,for,forEach三种方式的遍历和执行效率问题。","text":"java中对集合或数组等类型的数据遍历方式有很多，每种方式的时间复杂度和空间复杂度都各有差异，下面介绍下Iterator,for,forEach三种方式的遍历和执行效率问题。java中对集合或数组等类型的数据遍历方式有很多，每种方式的时间复杂度和空间复杂度都各有差异，下面介绍下Iterator,for,forEach三种方式的遍历和执行效率问题。 1.代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Test &#123; private static final int COUNT = 10000; private static List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); public static void init()&#123; //初始化，生成对象个数 Person person=null; for(int i=0;i&lt;COUNT;i++)&#123; person=new Person(i,\"张三\"+i,i+\"\"); persons.add(person); &#125; &#125; //Iterator遍历 public static long testIterator()&#123; //开始编译执行时间 long start =System.nanoTime(); Person person=null; for (Iterator&lt;Person&gt; iterator = persons.iterator(); iterator.hasNext();) &#123; person = (Person) iterator.next(); &#125; //执行完后的时间 long end =System.nanoTime(); return (end- start) / (1000); &#125; //foEach循环遍历 public static long testForEach()&#123; //开始编译执行时间 long start =System.nanoTime(); Person person=null; for(Person p:persons)&#123; person=p; &#125; //执行完后的时间 long end =System.nanoTime(); return (end- start) / (1000); &#125; //for循环遍历 public static long testFor()&#123; //开始编译执行时间 long start =System.nanoTime(); Person person=null; for(int i=0;i&lt;persons.size();i++)&#123; person=persons.get(i); &#125; //执行完后的时间 long end =System.nanoTime(); return (end- start) / (1000); &#125; public static void testRegxp()&#123; &#125; public static void main(String[] args) &#123; init(); System.out.println(\"Iterator迭代遍历的消耗时间为:\"+testIterator()); System.out.println(\"ForEach遍历的消耗时间为:\"+testForEach()); System.out.println(\"For循环遍历的消耗时间为:\"+testFor()); &#125;&#125; 2.测试结果：A.此结果是在10万级下测试的,此时forEach循环遍历耗时较少,For和Iterator耗时较多。 B.此结果是在1万级下测试的,此时for循环遍历耗时较少,ForEach和Iterator耗时较多。 综上若遍历的数据较多时，forEach效率较高，数量级较少是for循环效率较高。","categories":[{"name":"核心java","slug":"核心java","permalink":"http://hanyuanzhen.com/categories/核心java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hanyuanzhen.com/tags/java/"}]},{"title":"Spring集成AIXS2发布webservice","slug":"Spring集成AIXS2发布webservice","date":"2014-03-01T11:28:00.000Z","updated":"2017-03-11T13:10:27.000Z","comments":true,"path":"2014/03/01/Spring集成AIXS2发布webservice/","link":"","permalink":"http://hanyuanzhen.com/2014/03/01/Spring集成AIXS2发布webservice/","excerpt":"webservice技术，实现跨平台，跨语言进行数据的交互，系下面主要介绍总线如何整合AXIS2和Spring，发布和调用webservice。","text":"webservice技术，实现跨平台，跨语言进行数据的交互，系下面主要介绍总线如何整合AXIS2和Spring，发布和调用webservice。 一、简介webservice技术，实现跨平台，跨语言进行数据的交互，系下面主要介绍总线如何整合AXIS2和Spring，发布和调用webservice。 二、Spring整合AXIS2的步骤1.从官网下载Axis2的jar包2.建立一个web project，引入axis2相应的依赖包(路径为%\\axis2-1.5.4-bin%bin下)放到lib目录下目录结构如下： 3.定义工程的包结构如下: 4.在service中定义提供的服务接口service 实现类为：5.定义配置文件，并进行配置a.在src下建立applicationContext.xml文件,配置如下： b.在WebRoor/WEB-INF/services/目录下建立目录sampleService(这个名字可以随便取)然后建立在其下META-INF目录，然后再在其目录下建立services.xml ,目录结构如下: Services.xml的配置信息如下： C.配置web.xml文件，内容如下： 5.测试webservice的发布启动tomcat在浏览器中输入http://localhost:8080/Axis2Service/services.可以看到下内容说明我们的服务已经发布成功了 以上就是spring整合AXIS2的基本过程， 三、客户端和服务端的请求和响应1.客户端的调用方式有如下几种: 使用wsimport命令，生成本地代码（JDK） 使用service类来调用webservice（JDK） URLConnection来调用webservice（移动端） 前端调用：页面（Ajax）（SOAP协议的内容或格式） 2.Axis2调用webservice方式主要调用API为AXIS2包中RPCClient类，主要实现如下:","categories":[{"name":"SOA","slug":"SOA","permalink":"http://hanyuanzhen.com/categories/SOA/"}],"tags":[{"name":"webservice","slug":"webservice","permalink":"http://hanyuanzhen.com/tags/webservice/"},{"name":"AIXS2","slug":"AIXS2","permalink":"http://hanyuanzhen.com/tags/AIXS2/"}]}]}